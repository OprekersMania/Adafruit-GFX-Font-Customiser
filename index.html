
<html>
<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
  <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
  <style>
    html, body {
      margin: 0 10px;
    }
    textarea {
      font-family: "Courier", monotype;
      font-size: 0.9em !important;
    }

    .explanation ul {
      list-style-type: circle;
      margin: 0;
      padding-left: 14px;
    }

    .explanation h5 {
      margin-bottom: 4px;
      margin-top: 4px;
    }

    #glyphs div.inner {
      padding: 10px 0;
      position: relative;
    }
    #glyphs .centered.inner {
      padding: 10px;
      text-align: center;
    }

    #glyphs h2.inner {
      font-size: 2em;
      padding: 0.3em;
      text-align: center;
    }
    #glyphs div.table {
      user-select: none;
      position: relative;
      width: max-content;
      margin: auto;
    }
    #glyphs div.table div.row {
      height: 10px;
      position: relative;
    }
    #glyphs div.table div.row:first-child div.cell {
      height: 10px;
      border-top: 1px solid lightgrey;
    }
    #glyphs div.table div.cell {
      border-bottom: 1px solid lightgrey;
      border-right: 1px solid lightgrey;
      width: 10px;
      height: 10px;
      display: inline-block;
      cursor: pointer;
    }
    #glyphs div.table div.cell:first-child {
      border-left: 1px solid lightgrey;
    }
    #glyphs div.table div.cell.fill {
      background: black;
    }
    #glyphs div.table div.cell:hover {
      background: #999;
    }
    #glyphs div.table div.cell.fill.over {
      box-shadow: 0 0 9px #D00 inset;
    }
    #glyphs div.table div.cell.dead {
      background: #DDD;
    }
    #loader {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      font-weight: bold;
      font-size: 2em;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      display: flex;
      flex-direction: column;
    }
    .advance-wrapper {
      width: 300px;
      position: relative;
      border: 1px solid lightgray;
      height: 30px;
      margin-bottom: 20px;
    }
    .advance {
      opacity: 0.7;
      background: white;
      width: 10px;
      height: 24px;
      margin: 2px;
    }
    .baseline {
      position:absolute;
      left:0px;
      width:100%;
      height:1px;
      background-color:#090;
      opacity:0.6;
      pointer-events: none;
    }
    .limit {
      position: absolute;
      top: 0px;
      width: 2px;
      height: 100%;
      opacity: 0.4;
      pointer-events: none;
      background-color: #900;
    }
    #add {
      margin-top: 10px;
    }

    span.np {
      font-size: 0.5em;
      color: #CCC;
      font-style: italic;
    }

    .glyph-grid {
      display: flex;
      flex-wrap: wrap;
      align-items: stretch;
      justify-content: center;
    }
    .glyph-grid > div {
      margin: 1rem;
      box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
    }
	
	.ui.button, .ui.buttons .button, .ui.buttons .or {
		margin-bottom: 2px;
	}
   </style>
</head>
<body>
	<a href="https://github.com/tchapi/Adafruit-GFX-Font-Customiser"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
	<h1 class="ui header">Adafruit GFX Pixel font customiser</h1>
	<p>
	   <em>Created by <a href="https://github.com/tchapi">tchapi</a>, major improvements by <a href="https://github.com/cmarrin">cmarrin</a> and <a href="https://github.com/charno">charno</a> - Source code available on <a href="https://github.com/tchapi/Adafruit-GFX-Font-Customiser">Github</a>.</em>
	<h3 style="color:green"><u>Try my modification version with lot feature - <a href="Opreker_Version.html">CLICK HERE</a></u></h3>
	</p>
	<div class="ui divider"></div>
	<div class="ui grid">
	   <div class="eight wide column">
		  <div class="ui teal segment">
			 <div class="ui form">
				<div class="field">
				   <label>Extract font from source</label>
				   <textarea id="source" style="height: 228px;">>
// SAMPLE FONT FOR THIS PAGE
// Font Name	= Dernyn11full.h
// Font Height 	= 12 pixels
//            	  NOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// Script editor mod by DONY OPREKERS
const uint8_t Dernyn11fullBitmaps[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0xFF, 0x66, 
0x06, 0x60, 0xCF, 0x3C, 0xD2, 0x6C, 0xDB, 0xFB, 0x66, 0xCD, 0xBF, 0xB6, 
0x6C, 0x00, 0x31, 0xFC, 0x30, 0x78, 0x30, 0xFE, 0x30, 0x00, 0xC7, 0x31, 
0x8C, 0x63, 0x38, 0xC0, 0x71, 0xB3, 0x63, 0x8F, 0xBB, 0xF3, 0x6E, 0x76, 
0x6D, 0xE0, 0x19, 0x99, 0x8C, 0x61, 0x86, 0x18, 0xC3, 0x0C, 0x31, 0x8C, 
0xCC, 0xC0, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x30, 0xCF, 0xCC, 0x30, 0x77, 
0xC0, 0xFE, 0x00, 0x00, 0x00, 0x01, 0xCE, 0x70, 0x00, 0x02, 0x0C, 0x30, 
0xC3, 0x0C, 0x30, 0x40, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x3C, 0x08, 0x18, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x66, 
0x66, 0x06, 0x0C, 0x18, 0x30, 0x66, 0x7E, 0x3C, 0x66, 0x06, 0x06, 0x1C, 
0x06, 0x06, 0x66, 0x3C, 0x06, 0x0E, 0x1E, 0x36, 0x66, 0x7E, 0x06, 0x06, 
0x0F, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x1C, 0x30, 
0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x3C, 0x7E, 0x66, 0x66, 0x06, 0x0C, 
0x18, 0x30, 0x30, 0x30, 0x3C, 0x66, 0x66, 0x76, 0x3C, 0x6E, 0x66, 0x66, 
0x3C, 0x3C, 0x66, 0x66, 0x66, 0x3E, 0x0C, 0x0C, 0x18, 0x38, 0xFC, 0x0F, 
0xC0, 0xFC, 0x0F, 0xDE, 0x0C, 0x63, 0x18, 0xC1, 0x83, 0x06, 0x0C, 0xFC, 
0x0F, 0xC0, 0xC1, 0x83, 0x06, 0x0C, 0x63, 0x18, 0xC0, 0x7B, 0x30, 0xC6, 
0x30, 0xC0, 0x0C, 0x30, 0x7D, 0x8F, 0x1E, 0xFD, 0xFB, 0xF0, 0x60, 0x7C, 
0x31, 0xEC, 0xF3, 0xCF, 0xFC, 0xF3, 0xCC, 0xFC, 0xCD, 0x9B, 0x37, 0xCC, 
0xD9, 0xB3, 0xFC, 0x3C, 0xCF, 0x1E, 0x0C, 0x18, 0x31, 0xB3, 0x3C, 0xF8, 
0xD9, 0x9B, 0x36, 0x6C, 0xD9, 0xB6, 0xF8, 0xFE, 0xC5, 0x83, 0x27, 0xCC, 
0x98, 0x31, 0xFE, 0xFE, 0xCD, 0x8B, 0x27, 0xCC, 0x98, 0x30, 0xF0, 0x3C, 
0xCF, 0x1E, 0x0C, 0x19, 0xF1, 0xB3, 0x3E, 0xCF, 0x3C, 0xF3, 0xFF, 0x3C, 
0xF3, 0xCC, 0xF6, 0x66, 0x66, 0x66, 0xF0, 0x1E, 0x18, 0x30, 0x60, 0xD9, 
0xB3, 0x66, 0x78, 0xE6, 0xCD, 0xB3, 0x67, 0x8D, 0x9B, 0x33, 0xE6, 0xF0, 
0xC1, 0x83, 0x06, 0x0C, 0x59, 0xB3, 0xFE, 0xC7, 0xDF, 0xFF, 0xFD, 0x78, 
0xF1, 0xE3, 0xC6, 0xC7, 0x8F, 0x9F, 0xBF, 0xFB, 0xF3, 0xE3, 0xC6, 0x38, 
0xDB, 0x1E, 0x3C, 0x78, 0xF1, 0xB6, 0x38, 0xFC, 0xCD, 0x9B, 0x37, 0xCC, 
0x18, 0x30, 0xF0, 0x38, 0xDB, 0x1E, 0x3C, 0x79, 0xF7, 0xBE, 0x0C, 0x3C, 
0xFC, 0xCD, 0x9B, 0x37, 0xCD, 0x99, 0xB3, 0xE6, 0x7B, 0x3C, 0xF0, 0x70, 
0x6C, 0xF3, 0x78, 0xFE, 0xD3, 0x0C, 0x30, 0xC3, 0x0C, 0x78, 0xCF, 0x3C, 
0xF3, 0xCF, 0x3C, 0xF3, 0x78, 0xCF, 0x3C, 0xF3, 0xCF, 0x3C, 0xDE, 0x30, 
0xC7, 0x8F, 0x1E, 0x3D, 0x7A, 0xDB, 0x36, 0x6C, 0xCF, 0x3C, 0xDE, 0x31, 
0xEC, 0xF3, 0xCC, 0xCF, 0x3C, 0xF3, 0x78, 0xC3, 0x0C, 0x78, 0xFF, 0x9E, 
0x60, 0xC3, 0x0C, 0x18, 0xE3, 0xFE, 0xFC, 0xCC, 0xCC, 0xCC, 0xF0, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xF3, 0x33, 0x33, 0x33, 0xF0, 0x10, 
0x71, 0xB6, 0x30, 0xFF, 0xD9, 0x80, 0x78, 0x19, 0xF6, 0x6C, 0xCE, 0xC0, 
0xE0, 0xC1, 0x83, 0xE6, 0x6C, 0xD9, 0xB3, 0xDC, 0x7B, 0x3C, 0x30, 0xCD, 
0xE0, 0x1C, 0x18, 0x33, 0xEC, 0xD9, 0xB3, 0x66, 0x76, 0x7B, 0x3F, 0xF0, 
0xCD, 0xE0, 0x39, 0xB6, 0x18, 0xF9, 0x86, 0x18, 0xF0, 0x77, 0x9B, 0x36, 
0x67, 0xC1, 0xB3, 0x3C, 0xE0, 0xC1, 0x83, 0x67, 0x6C, 0xD9, 0xB3, 0xE6, 
0x30, 0xC0, 0x3C, 0x30, 0xC3, 0x0C, 0xFC, 0x0C, 0x30, 0x0F, 0x0C, 0x30, 
0xC3, 0xCF, 0x37, 0x80, 0xE0, 0xC1, 0x83, 0x36, 0xCF, 0x1B, 0x33, 0xE6, 
0xF0, 0xC3, 0x0C, 0x30, 0xC3, 0x0C, 0xFC, 0xFD, 0xAF, 0x5E, 0xBD, 0x7A, 
0xC0, 0xFB, 0x3C, 0xF3, 0xCF, 0x30, 0x7B, 0x3C, 0xF3, 0xCD, 0xE0, 0xDC, 
0xCD, 0x9B, 0x36, 0x6F, 0x98, 0x78, 0x77, 0x9B, 0x36, 0x6C, 0xCF, 0x83, 
0x0F, 0xEC, 0xDD, 0xDB, 0x06, 0x1E, 0x00, 0x7B, 0x36, 0x06, 0xCD, 0xE0, 
0x21, 0x8F, 0xD8, 0x61, 0x86, 0xCE, 0xCD, 0x9B, 0x36, 0x6C, 0xCE, 0xC0, 
0xCF, 0x3C, 0xF3, 0x78, 0xC0, 0xC7, 0xAF, 0x5E, 0xB6, 0xCD, 0x80, 0xC6, 
0xD8, 0xE1, 0xC6, 0xD8, 0xC0, 0x66, 0xCD, 0x9B, 0x33, 0xC1, 0x86, 0x78, 
0xFE, 0x31, 0x98, 0xC7, 0xF0, 0x1C, 0xC3, 0x18, 0xC1, 0x83, 0x0C, 0x1C, 
0xFF, 0x3F, 0xC0, 0xE0, 0xC3, 0x06, 0x0C, 0x63, 0x0C, 0xE0, 0x73, 0xDA, 
0xCE
};
const GFXglyph Dernyn11fullGlyphs[] PROGMEM = {
//    Pos  Col  Row  Xadv  Xoff  Base    Ascii hex   Char    Hex Count
{     0,   8,   9,   8,    0,    0 },   // 0x20     ' '     '9'
{     9,   4,   9,   5,    0,    0 },   // 0x21     '!'     '5'
{    14,   6,   4,   7,    0,    0 },   // 0x22     '"'     '3'
{    17,   7,   9,   8,    0,    0 },   // 0x23     '#'     '9'
{    26,   6,   9,   7,    0,    0 },   // 0x24     '$'     '8'
{    34,   6,   7,   7,    0,    2 },   // 0x25     '%'     '6'
{    40,   7,   9,   8,    0,    0 },   // 0x26     '&'     '8'
{    48,   3,   4,   4,    0,    0 },   // 0x27     '''     '2'
{    50,   5,   9,   6,    0,    0 },   // 0x28     '('     '6'
{    56,   5,   9,   6,    0,    0 },   // 0x29     ')'     '6'
{    62,   8,   5,   9,    0,    2 },   // 0x2A     '*'     '5'
{    67,   6,   5,   7,    0,    2 },   // 0x2B     '+'     '4'
{    71,   4,   3,   5,    0,    7 },   // 0x2C     ','     '2'
{    73,   7,   1,   8,    0,    4 },   // 0x2D     '-'     '1'
{    74,   5,   9,   5,    0,    0 },   // 0x2E     '.'     '7'
{    81,   7,   8,   8,    0,    1 },   // 0x2F     '/'     '7'
{    88,   8,   9,   8,    0,    0 },   // 0x30     '0'     '9'
{    97,   8,   9,   8,    0,    0 },   // 0x31     '1'     '9'
{   106,   8,   9,   8,    0,    0 },   // 0x32     '2'     '9'
{   115,   8,   9,   8,    0,    0 },   // 0x33     '3'     '9'
{   124,   8,   9,   8,    0,    0 },   // 0x34     '4'     '9'
{   133,   8,   9,   8,    0,    0 },   // 0x35     '5'     '9'
{   142,   8,   9,   8,    0,    0 },   // 0x36     '6'     '9'
{   151,   8,   9,   8,    0,    0 },   // 0x37     '7'     '9'
{   160,   8,   9,   8,    0,    0 },   // 0x38     '8'     '9'
{   169,   8,   9,   8,    0,    0 },   // 0x39     '9'     '9'
{   178,   3,   6,   4,    0,    2 },   // 0x3A     ':'     '3'
{   181,   3,   8,   4,    0,    2 },   // 0x3B     ';'     '3'
{   184,   6,   9,   7,    0,    0 },   // 0x3C     
{   191,   6,   3,   7,    0,    3 },   // 0x3D     
{   194,   6,   9,   7,    0,    0 },   // 0x3E     
{   201,   6,   9,   7,    0,    0 },   // 0x3F     '?'     '7'
{   208,   7,   9,   8,    0,    0 },   // 0x40     '@'     '8'
{   216,   6,   9,   7,    0,    0 },   // 0x41     'A'     '7'
{   223,   7,   9,   8,    0,    0 },   // 0x42     'B'     '8'
{   231,   7,   9,   8,    0,    0 },   // 0x43     'C'     '8'
{   239,   7,   9,   8,    0,    0 },   // 0x44     'D'     '8'
{   247,   7,   9,   8,    0,    0 },   // 0x45     'E'     '8'
{   255,   7,   9,   8,    0,    0 },   // 0x46     'F'     '8'
{   263,   7,   9,   8,    0,    0 },   // 0x47     'G'     '8'
{   271,   6,   9,   7,    0,    0 },   // 0x48     'H'     '7'
{   278,   4,   9,   5,    0,    0 },   // 0x49     'I'     '5'
{   283,   7,   9,   8,    0,    0 },   // 0x4A     'J'     '8'
{   291,   7,   9,   8,    0,    0 },   // 0x4B     'K'     '8'
{   299,   7,   9,   8,    0,    0 },   // 0x4C     'L'     '8'
{   307,   7,   9,   8,    0,    0 },   // 0x4D     'M'     '8'
{   315,   7,   9,   8,    0,    0 },   // 0x4E     'N'     '8'
{   323,   7,   9,   8,    0,    0 },   // 0x4F     'O'     '8'
{   331,   7,   9,   8,    0,    0 },   // 0x50     'P'     '8'
{   339,   7,  10,   8,    0,    0 },   // 0x51     'Q'     '9'
{   348,   7,   9,   8,    0,    0 },   // 0x52     'R'     '8'
{   356,   6,   9,   7,    0,    0 },   // 0x53     'S'     '7'
{   363,   6,   9,   7,    0,    0 },   // 0x54     'T'     '7'
{   370,   6,   9,   7,    0,    0 },   // 0x55     'U'     '7'
{   377,   6,   9,   7,    0,    0 },   // 0x56     'V'     '7'
{   384,   7,   9,   8,    0,    0 },   // 0x57     'W'     '8'
{   392,   6,   9,   7,    0,    0 },   // 0x58     'X'     '7'
{   399,   6,   9,   7,    0,    0 },   // 0x59     'Y'     '7'
{   406,   7,   9,   8,    0,    0 },   // 0x5A     'Z'     '8'
{   414,   4,   9,   5,    0,    0 },   // 0x5B     '['     '5'
{   419,   7,   8,   8,    0,    1 },   // 0x5C     '\'     '7'
{   426,   4,   9,   5,    0,    0 },   // 0x5D     ']'     '5'
{   431,   7,   4,   8,    0,    0 },   // 0x5E     '^'     '4'
{   435,   8,   1,   9,    0,    9 },   // 0x5F     '_'     '1'
{   436,   3,   3,   4,    0,    0 },   // 0x60     '`'     '2'
{   438,   7,   6,   8,    0,    3 },   // 0x61     'a'     '6'
{   444,   7,   9,   8,    0,    0 },   // 0x62     'b'     '8'
{   452,   6,   6,   7,    0,    3 },   // 0x63     'c'     '5'
{   457,   7,   9,   8,    0,    0 },   // 0x64     'd'     '8'
{   465,   6,   6,   7,    0,    3 },   // 0x65     'e'     '5'
{   470,   6,   9,   7,    0,    0 },   // 0x66     'f'     '7'
{   477,   7,   8,   8,    0,    3 },   // 0x67     'g'     '7'
{   484,   7,   9,   8,    0,    0 },   // 0x68     'h'     '8'
{   492,   6,   9,   7,    0,    0 },   // 0x69     'i'     '7'
{   499,   6,  11,   7,    0,    0 },   // 0x6A     'j'     '9'
{   508,   7,   9,   8,    0,    0 },   // 0x6B     'k'     '8'
{   516,   6,   9,   7,    0,    0 },   // 0x6C     'l'     '7'
{   523,   7,   6,   8,    0,    3 },   // 0x6D     'm'     '6'
{   529,   6,   6,   7,    0,    3 },   // 0x6E     'n'     '5'
{   534,   6,   6,   7,    0,    3 },   // 0x6F     'o'     '5'
{   539,   7,   8,   8,    0,    3 },   // 0x70     'p'     '7'
{   546,   7,   8,   8,    0,    3 },   // 0x71     'q'     '7'
{   553,   7,   6,   8,    0,    3 },   // 0x72     'r'     '6'
{   559,   6,   6,   7,    0,    3 },   // 0x73     's'     '5'
{   564,   6,   8,   7,    0,    1 },   // 0x74     't'     '6'
{   570,   7,   6,   8,    0,    3 },   // 0x75     'u'     '6'
{   576,   6,   6,   7,    0,    3 },   // 0x76     'v'     '5'
{   581,   7,   6,   8,    0,    3 },   // 0x77     'w'     '6'
{   587,   7,   6,   8,    0,    3 },   // 0x78     'x'     '6'
{   593,   7,   8,   8,    0,    3 },   // 0x79     'y'     '7'
{   600,   6,   6,   7,    0,    3 },   // 0x7A     'z'     '5'
{   605,   6,   9,   7,    0,    0 },   // 0x7B     '{'     '7'
{   612,   2,   9,   3,    0,    0 },   // 0x7C     '|'     '3'
{   615,   6,   9,   7,    0,    0 },   // 0x7D     '}'     '7'
{   622,   8,   3,   9,    0,    0 }    // 0x7E     '~'     '3'
};
const GFXfont Dernyn11full PROGMEM = {
(uint8_t *) Dernyn11fullBitmaps, 
(GFXglyph *)Dernyn11fullGlyphs, 0x20, 0x7E,    12 };
// File size approx : 10.46kb
				   </textarea>
				</div>
				<button class="ui button green" id="openFile"><i class="icon open folder"></i> Open File</button>
				<button class="ui button teal" id="extract"><i class="icon upload"></i> Extract</button>
				<button class="ui button red" id="reset"><i class="icon undo"></i> Reset</button>
				<button class="ui button blue" id="createFont"><i class="icon file outline"></i> Create a new font</button>
				<button class="ui button pink" id="clearText"><i class="eraser icon"></i>Clear TextArea</button>
			 </div>
		  </div>
	   </div>
	   <div class="eight wide column">
		  <div class="ui green segment" id="resultWrapper">
			 <div class="ui form">
				<div class="field">
				   <label>Output</label>
				   <textarea id="result"></textarea>
				</div>
				<div class="two fields">
				   <div class="field">
					  <label>First glyph to export</label>
					  <input type="text" id="firstglyph" value="0x00" />
				   </div>
				   <div class="field">
					  <label>Last glyph to export</label>
					  <input type="text" id="lastglyph" value="0x00" />
				   </div>
				</div>
				<button class="ui button green" id="export"><i class="icon download"></i> Process and create file</button>
				<button class="ui button red" id="savefile"><i class="save icon"></i>Save to file</button>
				<button class="ui button purple" id="copyToClip"><i class="copy icon"></i>Copy to Clipboard</button>
				<button class="ui button blue" id="reEdit" ><i class="recycle icon"></i>Re-Edit result</button>
			 </div>
		  </div>
	   </div>
	</div>
	<div class="ui divider"></div>
	<h2 class="ui header">How to use it</h2>
	<div class="ui grid">
	   <div class="five wide column">
		  <div class="ui explanation">
			 <h5>Importing or creating a font:</h5>
			 You can either:
			 <ul>
				<li>Extract a font by copying &amp; pasting the existing font source (a <kbd>.h</kbd> file) in the textarea above</li>
				<li>Create a new font with a single character</li>
			 </ul>
			 <h5>Adding characters:</h5>
			 <p>You can easily add new characters to the font afterwards. Interval characters will be added automatically <em>as disabled glyphs</em>.</p>
		  </div>
	   </div>
	   <div class="eleven wide column">
		  <div class="ui explanation">
			 <h5>Editing glyphs:</h5>
			 Glyphs can be edited individually. You can:
			 <ul>
				<li>Enable or disable the glyph</li>
				<li>Edit each pixel of the glyph</li>
				<li>Edit all values present in the GFXglyph data structure (See <a href="https://learn.adafruit.com/creating-custom-symbol-font-for-adafruit-gfx-library/understanding-the-font-specification">Adafruit documentation</a> for more information)</li>
			 </ul>
			 <h5>When exporting, you can either :</h5>
			 <ul>
				<li>Select a range of characters to include in the output. Characters outside of this range will <strong>not</strong> be included in the bitmap nor in the glyphs table.</li>
				<li>Disable individual characters. The disabled characters get all values set to <kbd>0</kbd>. There still are entries for the disabled characters in the glyphs table, but no data in the bitmap for them ‚Äî this keeps the characters in their correct places in the ASCII table.</li>
			 </ul>
		  </div>
	   </div>
	</div>
	<div class="ui divider"></div>
	<h2 class="ui header">Glyphs <em class="fontname" style="display: none;">FontName unknown</em></h2>
	<p><button class="ui small button violet" id="add" ><i class="icon add"></i> Add a new character</button></p>
	<div class="ui small modal choose">
	   <div class="header">Add a new character</div>
	   <div class="content">
		  <p>The character will be added to the set (<em>either at the end or at the beginning, depending on its code</em>), and if it is not contiguous with the previous set, <strong>the interval characters will be added too</strong>, but disabled, so that they do not take much space in the exported glyphs</p>
		  <form class="ui form">
			 <div class="field">
				<div class="ui toggle checkbox use-charcode">
				   <input type="checkbox" name="charcode" tabindex="0" class="hidden">
				   <label>Use char code (hex)</label>
				</div>
			 </div>
		  </form>
		  <div class="ui right labeled input">
			 <input type="text" id="new-character" placeholder="Character to add" maxlength="1">
			 <a class="ui label">
			 Char Code: <kbd class="charcode">N/A</kbd>
			 </a>
		  </div>
		  <div class="ui right labeled input">
			 <input type="text" id="new-character-code" placeholder="Character code to add (hex)" maxlength="4">
			 <a class="ui label">
			 Character: <kbd class="character">N/A</kbd>
			 </a>
		  </div>
	   </div>
	   <div class="actions">
		  <div class="ui cancel red button">Cancel</div>
		  <div class="ui approve green button">Add</div>
	   </div>
	</div>
	<div class="ui small modal newfont">
	   <div class="header">Create a new font</div>
	   <div class="content">
		  <p>To create a new font, you need to provide some details.</p>
		  <form class="ui form">
			 <div class="field">
				<label>Font name</label>
				<input type="text" id="newfont-name" placeholder="Name of the new font">
			 </div>
			 <div class="field">
				<label>Font height</label>
				<p>Font height in pixels</p>
				<input id="newfont-height"  type="number" value="1" min="1" placeholder="Height of the new font">
			 </div>
			 <div class="field">
				<label>First character</label>
				<p>The new font will be created with one character. You can add more characters later.</p>
				<div class="ui toggle checkbox newfont-use-charcode">
				   <input type="checkbox" name="newfontCharcode" tabindex="0" class="hidden">
				   <label>Use char code (hex)</label>
				</div>
			 </div>
		  </form>
		  <div class="ui right labeled input">
			 <input type="text" id="newfont-new-character" placeholder="Character to add" maxlength="1">
			 <a class="ui label">
			 Char Code: <kbd class="newfontCharcode">N/A</kbd>
			 </a>
		  </div>
		  <div class="ui right labeled input">
			 <input type="text" id="newfont-new-character-code" placeholder="Character code to add (hex)" maxlength="4">
			 <a class="ui label">
			 Character: <kbd class="newfontCharacter">N/A</kbd>
			 </a>
		  </div>
	   </div>
	   <div class="actions">
		  <div class="ui cancel red button">Cancel</div>
		  <div class="ui approve green button">Create</div>
	   </div>
	</div>
	<div class="ui small modal message">
	   <div class="header">‚ö†Ô∏è Warning</div>
	   <div class="content">
		  <p></p>
	   </div>
	   <div class="actions">
		  <div class="ui approve blue button">Ok</div>
	   </div>
	</div>
	<div class="ui small modal confirmation">
	   <div class="header">‚ö†Ô∏è Warning</div>
	   <div class="content">
		  <p></p>
	   </div>
	   <div class="actions">
		  <div class="ui cancel blue button">Cancel</div>
		  <div class="ui approve red button">Reset</div>
	   </div>
	</div>
	<div id="loader">
	   <div class="advance-wrapper">
		  <div class="advance"></div>
	   </div>
	   <span>Loading and extracting font ...</span>
	</div>
	<div id="glyphs" class="ui glyph-grid"><em>Please open or create a font first.</em></div>
</body>
<script>


// Function for file input and processing
document.getElementById('openFile').addEventListener('click', function () {
    // Create a file input element
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.h'; // Only accept .h files

    // Handle file selection
    fileInput.addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const content = e.target.result;

                // Clear the textarea first
                const textarea = document.getElementById('source');
                textarea.value = ''; // Clear previous content

                // Paste the content from the file
                textarea.value = content;

            };

            reader.readAsText(file); // Read file content
        }
    });
    // Trigger the file input click event
    fileInput.click();
});

function makeUpDownButton(name, func, color, width) {
    const button = $('<div class="ui mini compact buttons" style="margin:1px"></div>')
    const style = 'ui compact button ' + func + '-handler ' + color
    button.append('<button id="' + func + '-remove" class="' + style + '">-</button>')
    button.append('<button id="' + func + '-value" class="ui compact disabled button ' + color + '" style="width:' + width + ';padding:0;">' + name + '</button>')
    button.append('<button id="' + func + '-add" class="' + style + '">+</button>')
    return button
}

function makeCheckButton(name, func, color, width, disabled) {
    const button = $('<label class="ui ' + color + ' label" disabled style="width:' + width + '; cursor: pointer; margin-top: 1px; display: inline-flex; justify-content: center;"><input type="checkbox" class="' + func + '-handler" id="' + func + '"' + (disabled ? ' checked="checked"' : '') + '><span style="line-height: 13px; margin-left: 2px;">' + name + '</span></label>')
    return button
}

function makeGlyphItem(n, w, h, char, adv, ow, oh, disabled) {
    const charCode = char.charCodeAt(0)
    const table = $('<div class="table"></div>')
        .addClass('glyph')
        .attr('data-pixels', n)
        .attr('data-w', w)
        .attr('data-h', h)
        .attr('data-char', char)
        .attr('data-adv', adv)
        .attr('data-ow', ow)
        .attr('data-oh', oh)
        .attr('data-dis', disabled ? 1 : 0)
        .css('opacity', disabled ? 0.1 : 1)

    const grid = $(`<div style="width: ${window['glyph_table_width']}px"></div>`)
    const div = $('<div class="ui attached segment inner"></div>')

    div.append(table)

    if (char == ' ') {
        grid.append('<h2 class="ui top attached segment inner"><span class="np">space</span></h2>')
    } else {
        // Display a specific text for non-printable characters
        grid.append('<h2 class="ui top attached segment inner">' + char.replace(/[\x00-\x1F\x7F-\x9F\xAD]/g, '<span class="np">non-printable</span>') + '</h2>')
    }

    grid.append('<div class="ui attached segment inner secondary centered">' + '0x' + charCode.toString(16).toUpperCase() + '</div>')
    grid.append(div)

    const buttonBar = $('<div class="ui bottom attached warning message inner centered"></div>')

    buttonBar.append(makeUpDownButton('Rows: ' + h, 'row', 'purple', 60))
    buttonBar.append(makeUpDownButton('Cols: ' + w, 'col', 'violet', 60))
    buttonBar.append(makeUpDownButton('Base: ' + oh, 'base', 'green', 60))
    buttonBar.append(makeUpDownButton('XOff: ' + ow, 'xoff', 'blue', 60))
    buttonBar.append(makeUpDownButton('XAdv: ' + adv, 'xadv', 'teal', 60))
    buttonBar.append(makeClipButtons('clip', 'gray', 10))
    buttonBar.append(makeCheckButton('Disable', 'dis', 'yellow', 120, disabled))

    grid.append(buttonBar)

    return grid
}

function makeClipButtons(func, color, width) {
    const button = $('<div class="ui mini compact buttons" style="margin:1px; width: 121px;"></div>')
    const style = 'ui compact button ' + func + '-handler ' + color
    button.append('<button id="' + func + '-copy" class="' + style + '">COPY</button>')
    button.append('<button id="' + func + '-paste" class="' + style + '">PASTE</button>')
    return button
}

function setGlyphTable(table) {
    const xadvance = parseInt(table.attr('data-adv'))
    const maxH = parseInt(window['maxH'])

    const xoffset = parseInt(table.attr('data-ow'))
    const yoffset = parseInt(table.attr('data-oh'))

    const width = parseInt(table.attr('data-w'))
    const height = parseInt(table.attr('data-h'))

    const pixels = table.attr('data-pixels')

    const maxBaseline = window['maxBaseline']

    const left = xoffset
    const right = width + xoffset
    const top = maxBaseline + yoffset
    const bottom = top + height

    // Set the table
    table.empty()
    for (let i = 0; i < maxH; i++) {
        const row = $('<div></div>').addClass('row')
        for (let j = Math.min(0, xoffset); j <= Math.max(xadvance, right); j++) {
            const cell = $('<div></div>').addClass('cell').attr('data-x', j).attr('data-y', i)
            // These classes are used to position the "limits" vertical lines
            if (i === 0 && j === 0) {
                cell.addClass('before_xoffset')
            }
            if (i === 0 && j === xadvance) {
                cell.addClass('before_xadvance')
            }
            // Now draw the actual pixels
            if (i < top || i >= bottom || j < left || j >= right) {
                cell.addClass('dead')
            } else if (pixels.charAt((i - top) * width + (j - left)) == '1') {
                cell.addClass('fill')
            }
            // If the pixel is after xadvance, or before xoffset
            if (j >= xadvance || j < Math.max(0, xoffset)) {
                cell.addClass('over')
            }
            row.append(cell)
        }
        table.append(row)
    }

    // Draw the xadvance/xoffset limits
    // (We need to get the actual cell position before hand)
    const left_xoffset = table.find('div.before_xoffset')[0].offsetLeft
    xoffset_limit = $('<div class="xoffset_limit limit"></div>').css('left', (left_xoffset - 1) + 'px') // -1 accounts for first border of table
    table.append(xoffset_limit)

    const left_xadvance = table.find('div.before_xadvance')[0].offsetLeft
    xadvance_limit = $('<div class="xadvance_limit limit"></div>').css('left', (left_xadvance - 1) + 'px')
    table.append(xadvance_limit)

    // Set the baseline
    baseline = $('<div class="baseline"></div>').css('top', ((maxBaseline + 1) * 10 - 1) + 'px')
    table.append(baseline)
}

function updatePixels(table, newWidth, newHeight, x, y, fill) {
    const dataPixels = table.attr('data-pixels')
    const width = parseInt(table.attr('data-w'))
    const height = parseInt(table.attr('data-h'))
    const xoff = parseInt(table.attr('data-ow'))
    const base = parseInt(table.attr('data-oh'))
    const xAdjust = xoff * -1
    const yAdjust = (window['maxBaseline'] + base) * -1

    if (newWidth < 0) {
        newWidth = width
    }

    if (newHeight < 0) {
        newHeight = height
    }

    if (x >= 0 && y >= 0) {
        x += xAdjust
        y += yAdjust
    }

    // Store the pixels into a 2D bool array
    const array = []
    let pixelIndex = 0
    for (let i = 0; i < height; ++i) {
        const rowArray = []
        for (let j = 0; j < width; ++j) {
            if (x == j && y == i) {
                rowArray.push(fill)
            } else {
                rowArray.push(dataPixels.charAt(pixelIndex))
            }
            ++pixelIndex
        }
        array.push(rowArray)
    }

    // Write out to a string newWidth x newHeight
    let newPixels = ''
    for (let i = 0; i < newHeight; ++i) {
        for (let j = 0; j < newWidth; ++j) {
            if (i >= height || j >= width) {
                newPixels += '0'
            } else {
                newPixels += array[i][j]
            }
        }
    }

    // Pad out to a multiple of 8
    const pad = newPixels.length % 8
    for (let i = 0; i < pad; ++i) {
        newPixels += '0'
    }

    table.attr('data-pixels', newPixels)
}

function advanceLoading(percent) {
    const element = document.querySelector('#loader .advance')
    element.style.width = Math.floor(294 * percent)
}

function extractFont() {
    let data = $('#source').val()

    const bitmaps_part_re = /const\ uint8\_t\ (.*)Bitmaps\[\]/
    const glyph_part_re = /const\ GFXglyph/
    const font_part_re = /const\ GFXfont([\s\S]*)/g

    // Extract name
    const font_name = data.match(bitmaps_part_re)

    if (font_name != null && font_name.length > 1) {
        window['name'] = font_name[1]
    } else {
        alert('No correct font file found (name missing), please paste the content of an Adafruit GFX font file first.')
        $("#loader").hide()
        return
    }

    $('#glyphs').empty()

    // Extract GFXFont part
    const font_def = data.match(font_part_re)
    window['font_def'] = font_def[0]

    // Ignore any lines before the font definition (like headers, for instance)
    // In case the parts come out of order, cut the lines until the first of any
    // of the parts we are interested in.
    const slice_index = Math.min(
        data.indexOf(font_name[0]),
        data.indexOf(font_def[0]),
        data.search(glyph_part_re),
    )
    window.font_preamble = data.slice(0, slice_index)
    data = data.slice(slice_index)

    // Get first, last and yOffset
    let parts = font_def[0].split(',')
    const number_hexa_re = /0[xX][0-9a-fA-F]+/gi
    const number_dec_re = /[0-9]+/gi
    if (parts[2].match(number_hexa_re)) {
        window['first'] = parts[2].match(number_hexa_re)[0]
    } else if (parts[2].match(number_dec_re)) {
        window['first'] = '0x' + Number(parts[2].match(number_dec_re)[0]).toString(16)
    } else {
        alert('No correct font file found (first character offset unparsable), please paste the content of an Adafruit GFX font file first.')
        $("#loader").hide()
        return
    }

    if (parts[3].match(number_hexa_re)) {
        window['last'] = parts[3].match(number_hexa_re)[0]
    } else if (parts[3].match(number_dec_re)) {
        window['last'] = '0x' + Number(parts[3].match(number_dec_re)[0]).toString(16)
    } else {
        alert('No correct font file found (last character offset unparsable), please paste the content of an Adafruit GFX font file first.')
        $("#loader").hide()
        return
    }

    data = data.replace(font_def[0], '')
    data = data.replace(/\{/gi, '[').replace(/\}/gi, ']')
    data = data.replace('const GFXglyph ', '').replace('const uint8_t ', '').replace(/\[\]\ PROGMEM/gi, '')

    eval(data)

    /*
        // Tada üéâ
        console.log(window["name"])
        console.log(window["size"])
        console.log(window["first"])
        console.log(window["last"])
        console.log(window["font_def"])
        console.log(window[name + "Bitmaps"])
        console.log(window[name + "Glyphs"])
        */

    $('.fontname').text('(' + window['name'].slice(0, window['name'].length - 1) + ')').show()
    $('#firstglyph').val(window["first"])
    $('#lastglyph').val(window["last"])

    // $('#add').attr('disabled', false)

    const glyphsArray = window[name + 'Glyphs']

    // Run pre-calculations for correct display
    let maxW = 0
    let maxBaseline = 0
    let minUnderBaseline = 0
    for (ind in glyphsArray) {
        const inv_oh = -glyphsArray[ind][5]
        maxW = Math.max(maxW, glyphsArray[ind][1], glyphsArray[ind][3])
        maxBaseline = Math.max(maxBaseline, inv_oh)
        minUnderBaseline = Math.min(minUnderBaseline, inv_oh + 1 - glyphsArray[ind][2])
    }

    // Calculate the max height that we need for every glyph cell
    window['maxH'] = maxBaseline + 1 - minUnderBaseline

    // Space from the baseline to the top of the character cell is determined by the character with the
    // largest negative yOffset.
    window['maxBaseline'] = maxBaseline

    // Calculate the ideal glyph width. 160px is the minimum (for the buttons)
    window['glyph_table_width'] = Math.max(160, maxW * 11 + 30 /* some margin */ )

    // Display tables
    for (ind in glyphsArray) {
        const charIndex = parseInt(ind)
        // for each glyph
        const char = String.fromCharCode(parseInt(window['first'], 16) + charIndex)
        const w = glyphsArray[ind][1]
        const h = glyphsArray[ind][2]
        const adv = glyphsArray[ind][3]
        const ow = glyphsArray[ind][4]
        const oh = glyphsArray[ind][5]
        let n = ''

        // extract data: current offset
        currentOffset = glyphsArray[charIndex][0]

        // extract data: next offset
        if (charIndex + 1 < glyphsArray.length) {
            // To get the next offset, we need to find the next non-disabled
            // character offset (else, we will get 0 and it's not correct).
            let nextIndexIncrementor = 1
            do {
                nextOffset = glyphsArray[charIndex + nextIndexIncrementor][0]
                nextIndexIncrementor += 1
            } while (nextOffset === 0 && (charIndex + nextIndexIncrementor < glyphsArray.length))
            if (nextOffset === 0) { // We reached the end of the bitmaps
                nextOffset = window[name + 'Bitmaps'].length
            }
        } else {
            nextOffset = window[name + 'Bitmaps'].length
        }

        let disabled = (w == 0 || h == 0) && adv == 0

        if (!disabled) {
            for (let k = 0; k < (nextOffset - currentOffset); k++) {
                n += ('000000000' + window[name + 'Bitmaps'][currentOffset + k].toString(2)).substr(-8)
            }
        }

        grid = makeGlyphItem(n, w, h, char, adv, ow, oh, disabled)

        function glyphAppendClosure(el, adv) {
            setTimeout(function () {
                advanceLoading(0.2 * adv)
                $('#glyphs').append(el)
                if (adv === 1) {
                    // Run the setGlyphTable function now
                    displayGlyphTable()
                }
            }, 1)
        }

        glyphAppendClosure(grid, (charIndex + 1) / glyphsArray.length)
    }

    // $('#export').prop( "disabled", false )
    // $('#reset').prop("disabled", false)
    // $('#createFont').prop( "disabled", true )
    // $('#extract').prop( "disabled", true )
}

function displayGlyphTable() {
    const l = $('#glyphs').children().length
    $('#glyphs').children().each(function (i) {

        function setGlyphTableClosure(el, adv) {
            setTimeout(function () {
                advanceLoading(0.2 + 0.8 * adv)
                setGlyphTable(el.children().find('.glyph'))
                if (adv === 1) {
                    $('#loader').hide()
                }
            }, 1)
        }

        setGlyphTableClosure($(this), (i + 1) / l)
    })
}

$(document).ready(function () {

    var clip_data = {}

    $('#new-character-code').parent().hide()
    // $('#add').attr('disabled', 'disabled')
    // $('#export').attr('disabled', 'disabled')
    // $('#reset').prop("disabled", 'disabled')
    $('.ui.checkbox.use-charcode').checkbox()

    $(document).on('change', '.ui.checkbox.use-charcode input', function (e) {
        $('#new-character').parent().toggle()
        $('#new-character-code').parent().toggle()

        if ($('input[name=charcode]').is(':checked')) {
            if ($('#new-character-code').val() == '') {
                $('.character').text('N/A')
            } else {
                $('.character').text(String.fromCharCode(parseInt($('#new-character-code').val(), 16)))
            }
        } else {
            if ($('#new-character').val() == '') {
                $('.charcode').text('N/A')
            } else {
                $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
            }
        }
    })

    $('#newfont-new-character-code').parent().hide()
    $('.ui.checkbox.newfont-use-charcode').checkbox()
    $(document).on('change', '.ui.checkbox.newfont-use-charcode input', function (e) {
        $('#newfont-new-character').parent().toggle()
        $('#newfont-new-character-code').parent().toggle()

        if ($('input[name=newfontCharcode]').is(':checked')) {
            if ($('#newfont-new-character-code').val() == '') {
                $('.newfontCharacter').text('N/A')
            } else {
                $('.newfontCharacter').text(String.fromCharCode(parseInt($('#newfont-new-character-code').val(), 16)))
            }
        } else {
            if ($('#newfont-new-character').val() == '') {
                $('.newfontCharcode').text('N/A')
            } else {
                $('.newfontCharcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
            }
        }
    })

    $('#loader').hide()
    window['name'] = null
    window['font_def'] = null

    $('#clearText').click(function () {
        $('#source').val('')
    })

    $('#savefile').click(function () {
        var textToSave = document.getElementById("result").value; // Ambil teks dari elemen dengan id 'result'
        var textToSaveAsBlob = new Blob([textToSave], {
            type: "text/plain"
        }); // Buat Blob dari teks
        var textToSaveAsURL = window.URL.createObjectURL(textToSaveAsBlob); // Buat URL objek dari Blob

        var downloadLink = document.createElement("a"); // Membuat elemen <a> untuk link unduhan
        downloadLink.href = textToSaveAsURL; // Set link ke URL objek
        downloadLink.download = name + '.h'; // Tentukan nama file untuk diunduh
        downloadLink.innerHTML = "Download File"; // Teks untuk link (bisa diubah sesuai kebutuhan)
        downloadLink.onclick = function (event) {
            document.body.removeChild(event.target); // Hapus elemen setelah di-klik
        };
        downloadLink.style.display = "none"; // Sembunyikan link dari tampilan
        document.body.appendChild(downloadLink); // Tambahkan link ke body
        downloadLink.click(); // Klik link untuk memulai download
    });

    $('#reEdit').click(function () {
        let input = $('#result').val()
        if (input.length === 0) {
            document.getElementById("ErrorMsg").style.display = "block";
            setTimeout(function () {
                document.getElementById("ErrorMsg").style.display = "none";
            }, 1000);
            return;
        }
        $('#source').val('')
        $('#glyphs').empty()
        $('#source').val(input)
        extractFont()
        $('#result').val('')
    })


    $('#copyToClip').click(function () {

        var copyText = document.getElementById("result");
        copyText.select();
        copyText.setSelectionRange(0, 9999999); /*Change higher if all content not copied*/
        document.execCommand("copy");
    })
    $('#extract').click(function () {
        advanceLoading(0)
        $('#loader').fadeIn(function () {
            extractFont()
        })
    })

    $('#reset').click(function () {

        $('.ui.modal.confirmation p').text('The reset will close the font and discard any changes you made.')
        $('.ui.modal.confirmation').modal({
            closable: false,
            onApprove: function () {
                $('#glyphs').empty()
                $('#source').val('')
                // $('#createFont').prop("disabled", false)
                // $('#extract').prop("disabled", false)
                // $('#add').prop("disabled", "disabled")
                // $('#export').prop("disabled", "disabled")
                // $('#reset').prop("disabled", "disabled")
                $('.fontname').text('Fontname unknown').hide()
            }
        }).modal('show')
    })

    const fillPixel = (target, fill) => {
        fill === '1' ? target.addClass('fill') : target.removeClass('fill')
        const table = target.parent().parent().parent().find('.table.glyph')
        updatePixels(table, -1, -1, parseInt(target.attr('data-x')), parseInt(target.attr('data-y')), fill)
    }

    let isFilling = false;
    let fillingMode = '1';
    $(document).on('mousedown', '.cell:not(.dead)', function (e) {
        isFilling = true;
        fillingMode = $(e.target).hasClass('fill') ? '0' : '1'
        fillPixel($(e.target), fillingMode)
    })
    $(document).on('mouseup', '.cell:not(.dead)', function (e) {
        isFilling = false;
    })
    $(document).on('mouseenter', '.cell:not(.dead)', function (e) {
        if (isFilling) {
            fillPixel($(e.target), fillingMode)
        }
    })

    $(document).on('click', '.clip-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const actions = $(e.target).parent().parent()
        const table = actions.parent().find('.table.glyph')
        if (targetID === 'clip-copy') {
            clip_data.xadvance = parseInt(table.attr('data-adv'))
            clip_data.xoffset = parseInt(table.attr('data-ow'))
            clip_data.yoffset = parseInt(table.attr('data-oh'))
            clip_data.width = parseInt(table.attr('data-w'))
            clip_data.height = parseInt(table.attr('data-h'))
            clip_data.pixels = table.attr('data-pixels')
        } else if (targetID === 'clip-paste') {
            table.attr('data-adv', clip_data.xadvance)
            table.attr('data-ow', clip_data.xoffset)
            table.attr('data-oh', clip_data.yoffset)
            table.attr('data-w', clip_data.width)
            table.attr('data-h', clip_data.height)
            table.attr('data-pixels', clip_data.pixels)

            // Update button values
            actions.find('#row-value')[0].innerText = "Rows: " + clip_data.height
            actions.find('#col-value')[0].innerText = "Cols: " + clip_data.width
            actions.find('#base-value')[0].innerText = "Base: " + clip_data.yoffset
            actions.find('#xadv-value')[0].innerText = "XAdv: " + clip_data.xadvance
            actions.find('#xoff-value')[0].innerText = "XOff: " + clip_data.xoffset
        }
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.row-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#row-value')[0]

        let height = parseInt(table.attr('data-h'))

        if (targetID === 'row-add') {
            height++
        } else if (targetID === 'row-remove') {
            height--
        }

        updatePixels(table, -1, height, -1, -1, false)
        table.attr('data-h', height)
        valueDisplay.innerText = "Rows: " + height
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.col-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#col-value')[0]
        let width = parseInt(table.attr('data-w'))

        if (targetID === 'col-add') {
            width++
        } else if (targetID === 'col-remove') {
            width--
        }

        updatePixels(table, width, -1, -1, -1, false)
        table.attr('data-w', width)
        valueDisplay.innerText = "Cols: " + width
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.base-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#base-value')[0]
        let base = parseInt(table.attr('data-oh'))

        if (targetID === 'base-add') {
            base++
        } else if (targetID === 'base-remove') {
            base--
        }
        table.attr('data-oh', base)
        valueDisplay.innerText = "Base: " + base
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.xadv-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#xadv-value')[0]
        let xadv = parseInt(table.attr('data-adv'))

        if (targetID === 'xadv-add') {
            xadv++
        } else if (targetID === 'xadv-remove') {
            xadv--
        }
        table.attr('data-adv', xadv)
        valueDisplay.innerText = "XAdv: " + xadv
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.xoff-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#xoff-value')[0]
        let ow = parseInt(table.attr('data-ow'))

        if (targetID === 'xoff-add') {
            ow++
        } else if (targetID === 'xoff-remove') {
            ow--
        }
        table.attr('data-ow', ow)
        valueDisplay.innerText = "XOff: " + ow

        setGlyphTable(table)
        return false
    })

    $(document).on('change', '.dis-handler', function (e) {
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        table.attr('data-dis', 1 - parseInt(table.attr('data-dis')))
        table.fadeTo('fast', 1 - 0.9 * table.attr('data-dis'))
        return false
    })

    $(document).on('keyup', '#new-character', function (e) {
        if ($('#new-character').val() == '') {
            $('.charcode').text('N/A')
        } else {
            $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
        }
    })

    $(document).on('keyup', '#new-character-code', function (e) {
        if ($('#new-character-code').val() == '') {
            $('.character').text('N/A')
        } else {
            $('.character').text(String.fromCharCode(parseInt($('#new-character-code').val(), 16)))
        }
    })

    $(document).on('keyup', '#newfont-new-character', function (e) {
        if ($('#newfont-new-character').val() == '') {
            $('.newfontCharcode').text('N/A')
        } else {
            $('.newfontCharcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
        }
    })

    $(document).on('keyup', '#newfont-new-character-code', function (e) {
        if ($('#newfont-new-character-code').val() == '') {
            $('.newfontCharacter').text('N/A')
        } else {
            $('.newfontCharacter').text(String.fromCharCode(parseInt($('#newfont-new-character-code').val(), 16)))
        }
    })

    $('#createFont').click(function () {
        $('input[name=newfontCharcode]').prop('checked', false)
        $('#newfont-new-character').parent().show()
        $('#newfont-new-character-code').parent().hide()
        if ($('#newfont-new-character').val() == '') {
            $('.charcode').text('N/A')
        } else {
            $('.charcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
        }
        if ($('#newfont-new-character-code').val() == '') {
            $('.character').text('N/A')
        } else {
            $('.character').text(String.fromCharCode($('#newfont-new-character-code').val()))
        }

        $('.ui.modal.newfont').modal({
                closable: false,

                onApprove: function () {
                    let name = $('#newfont-name').val()
                    if (name.length < 1) {
                        $('.ui.modal.message p').text('The font must have a name, I\'m not creating a new font without it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }


                    let newfontHeight = parseInt($('#newfont-height').val())
                    if (newfontHeight < 1) {
                        $('.ui.modal.message p').text('The font height must be greater than 0, I\'m not creating a new font with this.')
                        $('.ui.modal.message').modal('show')
                        return
                    }


                    // Get new character data
                    let newChar
                    let newCharCode
                    if ($('input[name=newfontCharcode]').is(':checked')) {
                        newCharCode = parseInt($('#newfont-new-character-code').val(), 16)
                        newChar = String.fromCharCode(newCharCode)
                    } else {
                        newChar = $('#newfont-new-character').val()
                        newCharCode = $('#newfont-new-character').val().charCodeAt(0)
                    }

                    // Check character validity
                    if (newChar == '') {
                        $('.ui.modal.message p').text('This character is either blank or incorrect, I\'m not creating a new font with it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    if (newCharCode < 1) {
                        $('.ui.modal.message p').text('This is a special control character, I\'m not creating a new font with it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    if (newCharCode > 65535) {
                        $('.ui.modal.message p').text('This character is out of range, I\'m not creating a new font with it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    // Set the font parameters
                    window['first'] = newCharCode
                    window['last'] = newCharCode
                    window['name'] = name + '_'
                    window[name + '_Bitmaps'] = [] // This is otherwise created by the eval() in extract font
                    window['maxBaseline'] = newfontHeight
                    window['maxH'] = newfontHeight
                    window['font_def'] = 'const GFXfont ' + name + ' PROGMEM = {(uint8_t *) ' + name + '_Bitmaps, (GFXglyph *)' + name + '_Glyphs, 0x00, 0x00, ' + newfontHeight + '};'

                    // Show the data
                    $('.fontname').text('(' + name + ')').show()
                    $('#firstglyph').val('0x' + window["first"].toString(16))
                    $('#lastglyph').val('0x' + window["last"].toString(16))
                    $('#glyphs').empty()


                    // Change button states
                    $('#add').attr('disabled', false)
                    $('#export').prop("disabled", false)
                    $('#createFont').prop("disabled", true)
                    $('#extract').prop("disabled", true)
                    $('#reset').prop("disabled", false)

                    // Add the new character
                    const grid = makeGlyphItem(' ', 1, 1, newChar, 4, 0, -newfontHeight, false)
                    $('#glyphs').append(grid)

                    setGlyphTable(grid.find('.glyph'))
                }
            })
            .modal('show')
    })

    $('#add').click(function () {
        $('input[name=charcode]').prop('checked', false)
        $('#new-character').parent().show()
        $('#new-character-code').parent().hide()
        if ($('#new-character').val() == '') {
            $('.charcode').text('N/A')
        } else {
            $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
        }
        if ($('#new-character-code').val() == '') {
            $('.character').text('N/A')
        } else {
            $('.character').text(String.fromCharCode($('#new-character-code').val()))
        }

        // Choose a character
        $('.ui.modal.choose').modal({
                closable: false,
                onApprove: function () {
                    const firstglyph = parseInt($('#firstglyph').val(), 16)
                    const lastglyph = parseInt($('#lastglyph').val(), 16)

                    let newChar
                    let newCharCode
                    if ($('input[name=charcode]').is(':checked')) {
                        newCharCode = parseInt($('#new-character-code').val(), 16)
                        newChar = String.fromCharCode(newCharCode)
                    } else {
                        newChar = $('#new-character').val()
                        newCharCode = $('#new-character').val().charCodeAt(0)
                    }

                    if (newChar == '') {
                        $('.ui.modal.message p').text('This character is either blank or incorrect, I\'m not adding it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    if (newCharCode < 1) {
                        $('.ui.modal.message p').text('This is a special control character, I\'m not adding it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    if (newCharCode > 65535) {
                        $('.ui.modal.message p').text('This character is out of range, I\'m not adding it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    // Check that the character is not already existing
                    if (newCharCode > lastglyph || newCharCode < firstglyph) {
                        let start, end;
                        if (newCharCode > lastglyph) {
                            start = lastglyph + 1
                            end = newCharCode
                            window['last'] = '0x' + newCharCode.toString(16).toUpperCase()
                            $('#lastglyph').val(window['last'])
                        } else {
                            start = newCharCode
                            end = firstglyph - 1
                            window['first'] = '0x' + newCharCode.toString(16).toUpperCase()
                            $('#firstglyph').val(window['first'])
                        }

                        if (newCharCode < firstglyph) {
                            for (j = end; j >= start; j--) {
                                const char = String.fromCharCode(parseInt(j))
                                const grid = makeGlyphItem(' ', 1, 1, char, 4, 0, -window['maxBaseline'], !(j === newCharCode))
                                $('#glyphs').prepend(grid)
                                setGlyphTable(grid.find('.glyph'))
                            }
                        } else {
                            for (j = start; j <= end; j++) {
                                const char = String.fromCharCode(parseInt(j))
                                const grid = makeGlyphItem(' ', 1, 1, char, 4, 0, -window['maxBaseline'], !(j === newCharCode))
                                $('#glyphs').append(grid)
                                setGlyphTable(grid.find('.glyph'))
                            }
                        }

                    } else {
                        $('.ui.modal.message p').text('This character is already present in the actual set, I\'m not adding it.')
                        $('.ui.modal.message').modal('show')
                    }
                }
            })
            .modal('show');

    })

    $('#export').click(function () {
        const glyphs = []
        const bitsArray = []
        let offset = 0
        const firstglyph = parseInt($('#firstglyph').val(), 16)
        const lastglyph = parseInt($('#lastglyph').val(), 16)

        $('.table.glyph').each(function () {
            const t = $(this)
            // Ignore glyphs outside of requested range
            if (t.attr('data-char').charCodeAt(0) < firstglyph || t.attr('data-char').charCodeAt(0) > lastglyph) {
                return
            }

            var dataPixels = $(this).attr('data-pixels')
            if (t.attr('data-dis') == 1) {
                dataPixels = ''
            }
            let bits = ''

            for (let i = 0; i < dataPixels.length; i++) {
                bits += dataPixels.charAt(i)
                // Each 8 bits, we form the HEX value
                if (bits.length == 8) {
                    bitsArray.push('0x' + ('00' + parseInt((bits + '00000000').slice(0, 8), 2).toString(16).toUpperCase()).slice(-2))
                    bits = ''
                }
            }

            // Remaining bits with padding then, if necessary
            if (bits != '') {
                bitsArray.push('0x' + ('00' + parseInt((bits + '00000000').slice(0, 8), 2).toString(16).toUpperCase()).slice(-2))
            }

            // Set data width/height to 0 for disabled glyphs
            const w = parseInt(t.attr('data-w')) * (1 - parseInt(t.attr('data-dis')))
            const h = parseInt(t.attr('data-h')) * (1 - parseInt(t.attr('data-dis')))

            let char = t.attr('data-char')
            const charCode = char.charCodeAt(0).toString(16).toUpperCase()
            const charDisplay = char.replace(/[\x00-\x1F\x7F-\x9F\xAD]/g, 'non-printable')
            const comment = '// 0x' + charCode + ' \'' + charDisplay + '\''

            if (t.attr('data-dis') == 0) {
                glyphs.push(
                    '  { ' +
                    ('     ' + offset).slice(-5) + ', ' +
                    ('   ' + w).slice(-3) + ', ' +
                    ('   ' + h).slice(-3) + ', ' +
                    ('   ' + parseInt(t.attr('data-adv'))).slice(-3) + ', ' +
                    ('    ' + parseInt(t.attr('data-ow'))).slice(-4) + ', ' +
                    ('    ' + parseInt(t.attr('data-oh'))).slice(-4) + ' },   ' +
                    comment)
            } else {
                glyphs.push(
                    '  { ' +
                    '    0, ' +
                    '  0, ' +
                    '  0, ' +
                    '  0, ' +
                    '   0, ' +
                    '   0 },   ' +
                    comment)
            }

            offset = bitsArray.length
        })

        // Bitmaps
        let bitmapsOutput = 'const uint8_t ' + name + 'Bitmaps[] PROGMEM = {\n'
        // We want to join per 12 words
        const limit = Math.floor(bitsArray.length / 12)
        for (let nb = 0; nb < limit; nb++) {
            const isLastLine = (limit * 12 === bitsArray.length) && (nb === limit - 1)

            bitmapsOutput += '  ' + bitsArray[nb * 12] + ', ' +
                bitsArray[nb * 12 + 1] + ', ' +
                bitsArray[nb * 12 + 2] + ', ' +
                bitsArray[nb * 12 + 3] + ', ' +
                bitsArray[nb * 12 + 4] + ', ' +
                bitsArray[nb * 12 + 5] + ', ' +
                bitsArray[nb * 12 + 6] + ', ' +
                bitsArray[nb * 12 + 7] + ', ' +
                bitsArray[nb * 12 + 8] + ', ' +
                bitsArray[nb * 12 + 9] + ', ' +
                bitsArray[nb * 12 + 10] + ', ' +
                bitsArray[nb * 12 + 11] + (isLastLine ? '' : ',') + ' \n'
        }

        if (limit * 12 !== bitsArray.length) {
            bitmapsOutput += '  ' + bitsArray.slice(-(bitsArray.length - limit * 12)).join(', ') + '\n'
        }
        bitmapsOutput += '};\n\n'

        // Glyphs
        // The last glyph has a ',' too much at the end, we need to remove it (it's easier than to avoid putting it in the first place)
        glyphs[glyphs.length - 1] = glyphs[glyphs.length - 1].replace('},', '} ')
        let glyphsOutput = 'const GFXglyph ' + name + 'Glyphs[] PROGMEM = {\n'
        glyphsOutput += glyphs.join('\n') + '\n};\n\n'

        // Create a new font_def with the updated first & last glyph values in it
        let parts = window['font_def'].split(',')
        parts[2] = '0x' + firstglyph.toString(16).toUpperCase()
        parts[3] = '0x' + lastglyph.toString(16).toUpperCase()
        const updated_font_def = parts.join(", ", parts)

        data = bitmapsOutput + glyphsOutput + updated_font_def

        // Add back the font preamble, if present
        data = (window.font_preamble ?? '') + data

        $('#result').val(data)
    })
})
</script>
</html>
