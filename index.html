
<html>
<head>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
  <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
  <style>
    html, body {
      margin: 0 10px;
    }
    textarea {
      font-family: "Courier", monotype;
      font-size: 0.9em !important;
    }

    .explanation ul {
      list-style-type: circle;
      margin: 0;
      padding-left: 14px;
    }

    .explanation h5 {
      margin-bottom: 4px;
      margin-top: 4px;
    }

    #glyphs div.inner {
      padding: 10px 0;
      position: relative;
    }
    #glyphs .centered.inner {
      padding: 10px;
      text-align: center;
    }

    #glyphs h2.inner {
      font-size: 2em;
      padding: 0.3em;
      text-align: center;
    }
    #glyphs div.table {
      user-select: none;
      position: relative;
      width: max-content;
      margin: auto;
    }
    #glyphs div.table div.row {
      height: 10px;
      position: relative;
    }
    #glyphs div.table div.row:first-child div.cell {
      height: 10px;
      border-top: 1px solid lightgrey;
    }
    #glyphs div.table div.cell {
      border-bottom: 1px solid lightgrey;
      border-right: 1px solid lightgrey;
      width: 10px;
      height: 10px;
      display: inline-block;
      cursor: pointer;
    }
    #glyphs div.table div.cell:first-child {
      border-left: 1px solid lightgrey;
    }
    #glyphs div.table div.cell.fill {
      background: black;
    }
    #glyphs div.table div.cell:hover {
      background: #999;
    }
    #glyphs div.table div.cell.fill.over {
      box-shadow: 0 0 9px #D00 inset;
    }
    #glyphs div.table div.cell.dead {
      background: #DDD;
    }
    #loader {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      font-weight: bold;
      font-size: 2em;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      display: flex;
      flex-direction: column;
    }
    .advance-wrapper {
      width: 300px;
      position: relative;
      border: 1px solid lightgray;
      height: 30px;
      margin-bottom: 20px;
    }
    .advance {
      opacity: 0.7;
      background: white;
      width: 10px;
      height: 24px;
      margin: 2px;
    }
    .baseline {
      position:absolute;
      left:0px;
      width:100%;
      height:1px;
      background-color:#090;
      opacity:0.6;
      pointer-events: none;
    }
    .limit {
      position: absolute;
      top: 0px;
      width: 2px;
      height: 100%;
      opacity: 0.4;
      pointer-events: none;
      background-color: #900;
    }
    #add {
      margin-top: 10px;
    }

    span.np {
      font-size: 0.5em;
      color: #CCC;
      font-style: italic;
    }

    .glyph-grid {
      display: flex;
      flex-wrap: wrap;
      align-items: stretch;
      justify-content: center;
    }
    .glyph-grid > div {
      margin: 1rem;
      box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
    }
	
	.ui.button, .ui.buttons .button, .ui.buttons .or {
		margin-bottom: 2px;
	}
   </style>
</head>
<body>
	<a href="https://github.com/tchapi/Adafruit-GFX-Font-Customiser"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
	<h1 class="ui header">Adafruit GFX Pixel font customiser</h1>
	<p>
	   <em>Created by <a href="https://github.com/tchapi">tchapi</a>, major improvements by <a href="https://github.com/cmarrin">cmarrin</a> and <a href="https://github.com/charno">charno</a> - Source code available on <a href="https://github.com/tchapi/Adafruit-GFX-Font-Customiser">Github</a>.</em>
	<h3 style="color:green"><u>Try my modification version with lot feature - <a href="Opreker_Version.html">CLICK HERE</a></u></h3>
	</p>
	<div class="ui divider"></div>
	<div class="ui grid">
	   <div class="eight wide column">
		  <div class="ui teal segment">
			 <div class="ui form">
				<div class="field">
				   <label>Extract font from source</label>
				   <textarea id="source" style="height: 228px;">>
// SAMPLE FONT FOR THIS PAGE
// Font Name	= Dernyn11full.h
// Font Height 	= 12 pixels
//            	  NOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// Script editor mod by DONY OPREKERS
const uint8_t Dernyn11fullBitmaps[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0xFF, 0x66, 
0x06, 0x60, 0xCF, 0x3C, 0xD2, 0x6C, 0xDB, 0xFB, 0x66, 0xCD, 0xBF, 0xB6, 
0x6C, 0x00, 0x31, 0xFC, 0x30, 0x78, 0x30, 0xFE, 0x30, 0x00, 0xC7, 0x31, 
0x8C, 0x63, 0x38, 0xC0, 0x71, 0xB3, 0x63, 0x8F, 0xBB, 0xF3, 0x6E, 0x76, 
0x6D, 0xE0, 0x19, 0x99, 0x8C, 0x61, 0x86, 0x18, 0xC3, 0x0C, 0x31, 0x8C, 
0xCC, 0xC0, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x30, 0xCF, 0xCC, 0x30, 0x77, 
0xC0, 0xFE, 0x00, 0x00, 0x00, 0x01, 0xCE, 0x70, 0x00, 0x02, 0x0C, 0x30, 
0xC3, 0x0C, 0x30, 0x40, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x3C, 0x08, 0x18, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x66, 
0x66, 0x06, 0x0C, 0x18, 0x30, 0x66, 0x7E, 0x3C, 0x66, 0x06, 0x06, 0x1C, 
0x06, 0x06, 0x66, 0x3C, 0x06, 0x0E, 0x1E, 0x36, 0x66, 0x7E, 0x06, 0x06, 
0x0F, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x1C, 0x30, 
0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x3C, 0x7E, 0x66, 0x66, 0x06, 0x0C, 
0x18, 0x30, 0x30, 0x30, 0x3C, 0x66, 0x66, 0x76, 0x3C, 0x6E, 0x66, 0x66, 
0x3C, 0x3C, 0x66, 0x66, 0x66, 0x3E, 0x0C, 0x0C, 0x18, 0x38, 0xFC, 0x0F, 
0xC0, 0xFC, 0x0F, 0xDE, 0x0C, 0x63, 0x18, 0xC1, 0x83, 0x06, 0x0C, 0xFC, 
0x0F, 0xC0, 0xC1, 0x83, 0x06, 0x0C, 0x63, 0x18, 0xC0, 0x7B, 0x30, 0xC6, 
0x30, 0xC0, 0x0C, 0x30, 0x7D, 0x8F, 0x1E, 0xFD, 0xFB, 0xF0, 0x60, 0x7C, 
0x31, 0xEC, 0xF3, 0xCF, 0xFC, 0xF3, 0xCC, 0xFC, 0xCD, 0x9B, 0x37, 0xCC, 
0xD9, 0xB3, 0xFC, 0x3C, 0xCF, 0x1E, 0x0C, 0x18, 0x31, 0xB3, 0x3C, 0xF8, 
0xD9, 0x9B, 0x36, 0x6C, 0xD9, 0xB6, 0xF8, 0xFE, 0xC5, 0x83, 0x27, 0xCC, 
0x98, 0x31, 0xFE, 0xFE, 0xCD, 0x8B, 0x27, 0xCC, 0x98, 0x30, 0xF0, 0x3C, 
0xCF, 0x1E, 0x0C, 0x19, 0xF1, 0xB3, 0x3E, 0xCF, 0x3C, 0xF3, 0xFF, 0x3C, 
0xF3, 0xCC, 0xF6, 0x66, 0x66, 0x66, 0xF0, 0x1E, 0x18, 0x30, 0x60, 0xD9, 
0xB3, 0x66, 0x78, 0xE6, 0xCD, 0xB3, 0x67, 0x8D, 0x9B, 0x33, 0xE6, 0xF0, 
0xC1, 0x83, 0x06, 0x0C, 0x59, 0xB3, 0xFE, 0xC7, 0xDF, 0xFF, 0xFD, 0x78, 
0xF1, 0xE3, 0xC6, 0xC7, 0x8F, 0x9F, 0xBF, 0xFB, 0xF3, 0xE3, 0xC6, 0x38, 
0xDB, 0x1E, 0x3C, 0x78, 0xF1, 0xB6, 0x38, 0xFC, 0xCD, 0x9B, 0x37, 0xCC, 
0x18, 0x30, 0xF0, 0x38, 0xDB, 0x1E, 0x3C, 0x79, 0xF7, 0xBE, 0x0C, 0x3C, 
0xFC, 0xCD, 0x9B, 0x37, 0xCD, 0x99, 0xB3, 0xE6, 0x7B, 0x3C, 0xF0, 0x70, 
0x6C, 0xF3, 0x78, 0xFE, 0xD3, 0x0C, 0x30, 0xC3, 0x0C, 0x78, 0xCF, 0x3C, 
0xF3, 0xCF, 0x3C, 0xF3, 0x78, 0xCF, 0x3C, 0xF3, 0xCF, 0x3C, 0xDE, 0x30, 
0xC7, 0x8F, 0x1E, 0x3D, 0x7A, 0xDB, 0x36, 0x6C, 0xCF, 0x3C, 0xDE, 0x31, 
0xEC, 0xF3, 0xCC, 0xCF, 0x3C, 0xF3, 0x78, 0xC3, 0x0C, 0x78, 0xFF, 0x9E, 
0x60, 0xC3, 0x0C, 0x18, 0xE3, 0xFE, 0xFC, 0xCC, 0xCC, 0xCC, 0xF0, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xF3, 0x33, 0x33, 0x33, 0xF0, 0x10, 
0x71, 0xB6, 0x30, 0xFF, 0xD9, 0x80, 0x78, 0x19, 0xF6, 0x6C, 0xCE, 0xC0, 
0xE0, 0xC1, 0x83, 0xE6, 0x6C, 0xD9, 0xB3, 0xDC, 0x7B, 0x3C, 0x30, 0xCD, 
0xE0, 0x1C, 0x18, 0x33, 0xEC, 0xD9, 0xB3, 0x66, 0x76, 0x7B, 0x3F, 0xF0, 
0xCD, 0xE0, 0x39, 0xB6, 0x18, 0xF9, 0x86, 0x18, 0xF0, 0x77, 0x9B, 0x36, 
0x67, 0xC1, 0xB3, 0x3C, 0xE0, 0xC1, 0x83, 0x67, 0x6C, 0xD9, 0xB3, 0xE6, 
0x30, 0xC0, 0x3C, 0x30, 0xC3, 0x0C, 0xFC, 0x0C, 0x30, 0x0F, 0x0C, 0x30, 
0xC3, 0xCF, 0x37, 0x80, 0xE0, 0xC1, 0x83, 0x36, 0xCF, 0x1B, 0x33, 0xE6, 
0xF0, 0xC3, 0x0C, 0x30, 0xC3, 0x0C, 0xFC, 0xFD, 0xAF, 0x5E, 0xBD, 0x7A, 
0xC0, 0xFB, 0x3C, 0xF3, 0xCF, 0x30, 0x7B, 0x3C, 0xF3, 0xCD, 0xE0, 0xDC, 
0xCD, 0x9B, 0x36, 0x6F, 0x98, 0x78, 0x77, 0x9B, 0x36, 0x6C, 0xCF, 0x83, 
0x0F, 0xEC, 0xDD, 0xDB, 0x06, 0x1E, 0x00, 0x7B, 0x36, 0x06, 0xCD, 0xE0, 
0x21, 0x8F, 0xD8, 0x61, 0x86, 0xCE, 0xCD, 0x9B, 0x36, 0x6C, 0xCE, 0xC0, 
0xCF, 0x3C, 0xF3, 0x78, 0xC0, 0xC7, 0xAF, 0x5E, 0xB6, 0xCD, 0x80, 0xC6, 
0xD8, 0xE1, 0xC6, 0xD8, 0xC0, 0x66, 0xCD, 0x9B, 0x33, 0xC1, 0x86, 0x78, 
0xFE, 0x31, 0x98, 0xC7, 0xF0, 0x1C, 0xC3, 0x18, 0xC1, 0x83, 0x0C, 0x1C, 
0xFF, 0x3F, 0xC0, 0xE0, 0xC3, 0x06, 0x0C, 0x63, 0x0C, 0xE0, 0x73, 0xDA, 
0xCE
};
const GFXglyph Dernyn11fullGlyphs[] PROGMEM = {
//    Pos  Col  Row  Xadv  Xoff  Base    Ascii hex   Char    Hex Count
{     0,   8,   9,   8,    0,    0 },   // 0x20     ' '     '9'
{     9,   4,   9,   5,    0,    0 },   // 0x21     '!'     '5'
{    14,   6,   4,   7,    0,    0 },   // 0x22     '"'     '3'
{    17,   7,   9,   8,    0,    0 },   // 0x23     '#'     '9'
{    26,   6,   9,   7,    0,    0 },   // 0x24     '$'     '8'
{    34,   6,   7,   7,    0,    2 },   // 0x25     '%'     '6'
{    40,   7,   9,   8,    0,    0 },   // 0x26     '&'     '8'
{    48,   3,   4,   4,    0,    0 },   // 0x27     '''     '2'
{    50,   5,   9,   6,    0,    0 },   // 0x28     '('     '6'
{    56,   5,   9,   6,    0,    0 },   // 0x29     ')'     '6'
{    62,   8,   5,   9,    0,    2 },   // 0x2A     '*'     '5'
{    67,   6,   5,   7,    0,    2 },   // 0x2B     '+'     '4'
{    71,   4,   3,   5,    0,    7 },   // 0x2C     ','     '2'
{    73,   7,   1,   8,    0,    4 },   // 0x2D     '-'     '1'
{    74,   5,   9,   5,    0,    0 },   // 0x2E     '.'     '7'
{    81,   7,   8,   8,    0,    1 },   // 0x2F     '/'     '7'
{    88,   8,   9,   8,    0,    0 },   // 0x30     '0'     '9'
{    97,   8,   9,   8,    0,    0 },   // 0x31     '1'     '9'
{   106,   8,   9,   8,    0,    0 },   // 0x32     '2'     '9'
{   115,   8,   9,   8,    0,    0 },   // 0x33     '3'     '9'
{   124,   8,   9,   8,    0,    0 },   // 0x34     '4'     '9'
{   133,   8,   9,   8,    0,    0 },   // 0x35     '5'     '9'
{   142,   8,   9,   8,    0,    0 },   // 0x36     '6'     '9'
{   151,   8,   9,   8,    0,    0 },   // 0x37     '7'     '9'
{   160,   8,   9,   8,    0,    0 },   // 0x38     '8'     '9'
{   169,   8,   9,   8,    0,    0 },   // 0x39     '9'     '9'
{   178,   3,   6,   4,    0,    2 },   // 0x3A     ':'     '3'
{   181,   3,   8,   4,    0,    2 },   // 0x3B     ';'     '3'
{   184,   6,   9,   7,    0,    0 },   // 0x3C     
{   191,   6,   3,   7,    0,    3 },   // 0x3D     
{   194,   6,   9,   7,    0,    0 },   // 0x3E     
{   201,   6,   9,   7,    0,    0 },   // 0x3F     '?'     '7'
{   208,   7,   9,   8,    0,    0 },   // 0x40     '@'     '8'
{   216,   6,   9,   7,    0,    0 },   // 0x41     'A'     '7'
{   223,   7,   9,   8,    0,    0 },   // 0x42     'B'     '8'
{   231,   7,   9,   8,    0,    0 },   // 0x43     'C'     '8'
{   239,   7,   9,   8,    0,    0 },   // 0x44     'D'     '8'
{   247,   7,   9,   8,    0,    0 },   // 0x45     'E'     '8'
{   255,   7,   9,   8,    0,    0 },   // 0x46     'F'     '8'
{   263,   7,   9,   8,    0,    0 },   // 0x47     'G'     '8'
{   271,   6,   9,   7,    0,    0 },   // 0x48     'H'     '7'
{   278,   4,   9,   5,    0,    0 },   // 0x49     'I'     '5'
{   283,   7,   9,   8,    0,    0 },   // 0x4A     'J'     '8'
{   291,   7,   9,   8,    0,    0 },   // 0x4B     'K'     '8'
{   299,   7,   9,   8,    0,    0 },   // 0x4C     'L'     '8'
{   307,   7,   9,   8,    0,    0 },   // 0x4D     'M'     '8'
{   315,   7,   9,   8,    0,    0 },   // 0x4E     'N'     '8'
{   323,   7,   9,   8,    0,    0 },   // 0x4F     'O'     '8'
{   331,   7,   9,   8,    0,    0 },   // 0x50     'P'     '8'
{   339,   7,  10,   8,    0,    0 },   // 0x51     'Q'     '9'
{   348,   7,   9,   8,    0,    0 },   // 0x52     'R'     '8'
{   356,   6,   9,   7,    0,    0 },   // 0x53     'S'     '7'
{   363,   6,   9,   7,    0,    0 },   // 0x54     'T'     '7'
{   370,   6,   9,   7,    0,    0 },   // 0x55     'U'     '7'
{   377,   6,   9,   7,    0,    0 },   // 0x56     'V'     '7'
{   384,   7,   9,   8,    0,    0 },   // 0x57     'W'     '8'
{   392,   6,   9,   7,    0,    0 },   // 0x58     'X'     '7'
{   399,   6,   9,   7,    0,    0 },   // 0x59     'Y'     '7'
{   406,   7,   9,   8,    0,    0 },   // 0x5A     'Z'     '8'
{   414,   4,   9,   5,    0,    0 },   // 0x5B     '['     '5'
{   419,   7,   8,   8,    0,    1 },   // 0x5C     '\'     '7'
{   426,   4,   9,   5,    0,    0 },   // 0x5D     ']'     '5'
{   431,   7,   4,   8,    0,    0 },   // 0x5E     '^'     '4'
{   435,   8,   1,   9,    0,    9 },   // 0x5F     '_'     '1'
{   436,   3,   3,   4,    0,    0 },   // 0x60     '`'     '2'
{   438,   7,   6,   8,    0,    3 },   // 0x61     'a'     '6'
{   444,   7,   9,   8,    0,    0 },   // 0x62     'b'     '8'
{   452,   6,   6,   7,    0,    3 },   // 0x63     'c'     '5'
{   457,   7,   9,   8,    0,    0 },   // 0x64     'd'     '8'
{   465,   6,   6,   7,    0,    3 },   // 0x65     'e'     '5'
{   470,   6,   9,   7,    0,    0 },   // 0x66     'f'     '7'
{   477,   7,   8,   8,    0,    3 },   // 0x67     'g'     '7'
{   484,   7,   9,   8,    0,    0 },   // 0x68     'h'     '8'
{   492,   6,   9,   7,    0,    0 },   // 0x69     'i'     '7'
{   499,   6,  11,   7,    0,    0 },   // 0x6A     'j'     '9'
{   508,   7,   9,   8,    0,    0 },   // 0x6B     'k'     '8'
{   516,   6,   9,   7,    0,    0 },   // 0x6C     'l'     '7'
{   523,   7,   6,   8,    0,    3 },   // 0x6D     'm'     '6'
{   529,   6,   6,   7,    0,    3 },   // 0x6E     'n'     '5'
{   534,   6,   6,   7,    0,    3 },   // 0x6F     'o'     '5'
{   539,   7,   8,   8,    0,    3 },   // 0x70     'p'     '7'
{   546,   7,   8,   8,    0,    3 },   // 0x71     'q'     '7'
{   553,   7,   6,   8,    0,    3 },   // 0x72     'r'     '6'
{   559,   6,   6,   7,    0,    3 },   // 0x73     's'     '5'
{   564,   6,   8,   7,    0,    1 },   // 0x74     't'     '6'
{   570,   7,   6,   8,    0,    3 },   // 0x75     'u'     '6'
{   576,   6,   6,   7,    0,    3 },   // 0x76     'v'     '5'
{   581,   7,   6,   8,    0,    3 },   // 0x77     'w'     '6'
{   587,   7,   6,   8,    0,    3 },   // 0x78     'x'     '6'
{   593,   7,   8,   8,    0,    3 },   // 0x79     'y'     '7'
{   600,   6,   6,   7,    0,    3 },   // 0x7A     'z'     '5'
{   605,   6,   9,   7,    0,    0 },   // 0x7B     '{'     '7'
{   612,   2,   9,   3,    0,    0 },   // 0x7C     '|'     '3'
{   615,   6,   9,   7,    0,    0 },   // 0x7D     '}'     '7'
{   622,   8,   3,   9,    0,    0 }    // 0x7E     '~'     '3'
};
const GFXfont Dernyn11full PROGMEM = {
(uint8_t *) Dernyn11fullBitmaps, 
(GFXglyph *)Dernyn11fullGlyphs, 0x20, 0x7E,    12 };
// File size approx : 10.46kb
				   </textarea>
				</div>
				<button class="ui button green" id="openFile"><i class="icon open folder"></i> Open File</button>
				<button class="ui button teal" id="extract"><i class="icon upload"></i> Extract</button>
				<button class="ui button red" id="reset"><i class="icon undo"></i> Reset</button>
				<button class="ui button blue" id="createFont"><i class="icon file outline"></i> Create a new font</button>
				<button class="ui button pink" id="clearText"><i class="eraser icon"></i>Clear TextArea</button>
			 </div>
		  </div>
	   </div>
	   <div class="eight wide column">
		  <div class="ui green segment" id="resultWrapper">
			 <div class="ui form">
				<div class="field">
				   <label>Output</label>
				   <textarea id="result"></textarea>
				</div>
				<div class="two fields">
				   <div class="field">
					  <label>First glyph to export</label>
					  <input type="text" id="firstglyph" value="0x00" />
				   </div>
				   <div class="field">
					  <label>Last glyph to export</label>
					  <input type="text" id="lastglyph" value="0x00" />
				   </div>
				</div>
				<button class="ui button green" id="export"><i class="icon download"></i> Process and create file</button>
				<button class="ui button red" id="savefile"><i class="save icon"></i>Save to file</button>
				<button class="ui button purple" id="copyToClip"><i class="copy icon"></i>Copy to Clipboard</button>
				<button class="ui button blue" id="reEdit" ><i class="recycle icon"></i>Re-Edit result</button>
			 </div>
		  </div>
	   </div>
	</div>
	<div class="ui divider"></div>
	<h2 class="ui header">How to use it</h2>
	<div class="ui grid">
	   <div class="five wide column">
		  <div class="ui explanation">
			 <h5>Importing or creating a font:</h5>
			 You can either:
			 <ul>
				<li>Extract a font by copying &amp; pasting the existing font source (a <kbd>.h</kbd> file) in the textarea above</li>
				<li>Create a new font with a single character</li>
			 </ul>
			 <h5>Adding characters:</h5>
			 <p>You can easily add new characters to the font afterwards. Interval characters will be added automatically <em>as disabled glyphs</em>.</p>
		  </div>
	   </div>
	   <div class="eleven wide column">
		  <div class="ui explanation">
			 <h5>Editing glyphs:</h5>
			 Glyphs can be edited individually. You can:
			 <ul>
				<li>Enable or disable the glyph</li>
				<li>Edit each pixel of the glyph</li>
				<li>Edit all values present in the GFXglyph data structure (See <a href="https://learn.adafruit.com/creating-custom-symbol-font-for-adafruit-gfx-library/understanding-the-font-specification">Adafruit documentation</a> for more information)</li>
			 </ul>
			 <h5>When exporting, you can either :</h5>
			 <ul>
				<li>Select a range of characters to include in the output. Characters outside of this range will <strong>not</strong> be included in the bitmap nor in the glyphs table.</li>
				<li>Disable individual characters. The disabled characters get all values set to <kbd>0</kbd>. There still are entries for the disabled characters in the glyphs table, but no data in the bitmap for them — this keeps the characters in their correct places in the ASCII table.</li>
			 </ul>
		  </div>
	   </div>
	</div>
	<div class="ui divider"></div>
	<h2 class="ui header">Glyphs <em class="fontname" style="display: none;">FontName unknown</em></h2>
	<p><button class="ui small button violet" id="add" ><i class="icon add"></i> Add a new character</button></p>
	<div class="ui small modal choose">
	   <div class="header">Add a new character</div>
	   <div class="content">
		  <p>The character will be added to the set (<em>either at the end or at the beginning, depending on its code</em>), and if it is not contiguous with the previous set, <strong>the interval characters will be added too</strong>, but disabled, so that they do not take much space in the exported glyphs</p>
		  <form class="ui form">
			 <div class="field">
				<div class="ui toggle checkbox use-charcode">
				   <input type="checkbox" name="charcode" tabindex="0" class="hidden">
				   <label>Use char code (hex)</label>
				</div>
			 </div>
		  </form>
		  <div class="ui right labeled input">
			 <input type="text" id="new-character" placeholder="Character to add" maxlength="1">
			 <a class="ui label">
			 Char Code: <kbd class="charcode">N/A</kbd>
			 </a>
		  </div>
		  <div class="ui right labeled input">
			 <input type="text" id="new-character-code" placeholder="Character code to add (hex)" maxlength="4">
			 <a class="ui label">
			 Character: <kbd class="character">N/A</kbd>
			 </a>
		  </div>
	   </div>
	   <div class="actions">
		  <div class="ui cancel red button">Cancel</div>
		  <div class="ui approve green button">Add</div>
	   </div>
	</div>
	<div class="ui small modal newfont">
	   <div class="header">Create a new font</div>
	   <div class="content">
		  <p>To create a new font, you need to provide some details.</p>
		  <form class="ui form">
			 <div class="field">
				<label>Font name</label>
				<input type="text" id="newfont-name" placeholder="Name of the new font">
			 </div>
			 <div class="field">
				<label>Font height</label>
				<p>Font height in pixels</p>
				<input id="newfont-height"  type="number" value="1" min="1" placeholder="Height of the new font">
			 </div>
			 <div class="field">
				<label>First character</label>
				<p>The new font will be created with one character. You can add more characters later.</p>
				<div class="ui toggle checkbox newfont-use-charcode">
				   <input type="checkbox" name="newfontCharcode" tabindex="0" class="hidden">
				   <label>Use char code (hex)</label>
				</div>
			 </div>
		  </form>
		  <div class="ui right labeled input">
			 <input type="text" id="newfont-new-character" placeholder="Character to add" maxlength="1">
			 <a class="ui label">
			 Char Code: <kbd class="newfontCharcode">N/A</kbd>
			 </a>
		  </div>
		  <div class="ui right labeled input">
			 <input type="text" id="newfont-new-character-code" placeholder="Character code to add (hex)" maxlength="4">
			 <a class="ui label">
			 Character: <kbd class="newfontCharacter">N/A</kbd>
			 </a>
		  </div>
	   </div>
	   <div class="actions">
		  <div class="ui cancel red button">Cancel</div>
		  <div class="ui approve green button">Create</div>
	   </div>
	</div>
	<div class="ui small modal message">
	   <div class="header">⚠️ Warning</div>
	   <div class="content">
		  <p></p>
	   </div>
	   <div class="actions">
		  <div class="ui approve blue button">Ok</div>
	   </div>
	</div>
	<div class="ui small modal confirmation">
	   <div class="header">⚠️ Warning</div>
	   <div class="content">
		  <p></p>
	   </div>
	   <div class="actions">
		  <div class="ui cancel blue button">Cancel</div>
		  <div class="ui approve red button">Reset</div>
	   </div>
	</div>
	<div id="loader">
	   <div class="advance-wrapper">
		  <div class="advance"></div>
	   </div>
	   <span>Loading and extracting font ...</span>
	</div>
	<div id="glyphs" class="ui glyph-grid"><em>Please open or create a font first.</em></div>
</body>
<script>


// Function for file input and processing
document.getElementById('openFile').addEventListener('click', function () {
    // Create a file input element
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.h'; // Only accept .h files

    // Handle file selection
    fileInput.addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const content = e.target.result;

                // Clear the textarea first
                const textarea = document.getElementById('source');
                textarea.value = ''; // Clear previous content

                // Paste the content from the file
                textarea.value = content;

            };

            reader.readAsText(file); // Read file content
        }
    });
    // Trigger the file input click event
    fileInput.click();
});

function makeUpDownButton(name, func, color, width) {
    const button = $('<div class="ui mini compact buttons" style="margin:1px"></div>')
    const style = 'ui compact button ' + func + '-handler ' + color
    button.append('<button id="' + func + '-remove" class="' + style + '">-</button>')
    button.append('<button id="' + func + '-value" class="ui compact disabled button ' + color + '" style="width:' + width + ';padding:0;">' + name + '</button>')
    button.append('<button id="' + func + '-add" class="' + style + '">+</button>')
    return button
}

function makeCheckButton(name, func, color, width, disabled) {
    const button = $('<label class="ui ' + color + ' label" disabled style="width:' + width + '; cursor: pointer; margin-top: 1px; display: inline-flex; justify-content: center;"><input type="checkbox" class="' + func + '-handler" id="' + func + '"' + (disabled ? ' checked="checked"' : '') + '><span style="line-height: 13px; margin-left: 2px;">' + name + '</span></label>')
    return button
}

function makeGlyphItem(n, w, h, char, adv, ow, oh, disabled) {
    const charCode = char.charCodeAt(0)
    const table = $('<div class="table"></div>')
        .addClass('glyph')
        .attr('data-pixels', n)
        .attr('data-w', w)
        .attr('data-h', h)
        .attr('data-char', char)
        .attr('data-adv', adv)
        .attr('data-ow', ow)
        .attr('data-oh', oh)
        .attr('data-dis', disabled ? 1 : 0)
        .css('opacity', disabled ? 0.1 : 1)

    const grid = $(`<div style="width: ${window['glyph_table_width']}px"></div>`)
    const div = $('<div class="ui attached segment inner"></div>')

    div.append(table)

    if (char == ' ') {
        grid.append('<h2 class="ui top attached segment inner"><span class="np">space</span></h2>')
    } else {
        // Display a specific text for non-printable characters
        grid.append('<h2 class="ui top attached segment inner">' + char.replace(/[\x00-\x1F\x7F-\x9F\xAD]/g, '<span class="np">non-printable</span>') + '</h2>')
    }

    grid.append('<div class="ui attached segment inner secondary centered">' + '0x' + charCode.toString(16).toUpperCase() + '</div>')
    grid.append(div)

    const buttonBar = $('<div class="ui bottom attached warning message inner centered"></div>')

    buttonBar.append(makeUpDownButton('Rows: ' + h, 'row', 'purple', 60))
    buttonBar.append(makeUpDownButton('Cols: ' + w, 'col', 'violet', 60))
    buttonBar.append(makeUpDownButton('Base: ' + oh, 'base', 'green', 60))
    buttonBar.append(makeUpDownButton('XOff: ' + ow, 'xoff', 'blue', 60))
    buttonBar.append(makeUpDownButton('XAdv: ' + adv, 'xadv', 'teal', 60))
    buttonBar.append(makeClipButtons('clip', 'gray', 10))
    buttonBar.append(makeCheckButton('Disable', 'dis', 'yellow', 120, disabled))

    grid.append(buttonBar)

    return grid
}

function makeClipButtons(func, color, width) {
    const button = $('<div class="ui mini compact buttons" style="margin:1px; width: 121px;"></div>')
    const style = 'ui compact button ' + func + '-handler ' + color
    button.append('<button id="' + func + '-copy" class="' + style + '">COPY</button>')
    button.append('<button id="' + func + '-paste" class="' + style + '">PASTE</button>')
    return button
}

function setGlyphTable(table) {
    const xadvance = parseInt(table.attr('data-adv'))
    const maxH = parseInt(window['maxH'])

    const xoffset = parseInt(table.attr('data-ow'))
    const yoffset = parseInt(table.attr('data-oh'))

    const width = parseInt(table.attr('data-w'))
    const height = parseInt(table.attr('data-h'))

    const pixels = table.attr('data-pixels')

    const maxBaseline = window['maxBaseline']

    const left = xoffset
    const right = width + xoffset
    const top = maxBaseline + yoffset
    const bottom = top + height

    // Set the table
    table.empty()
    for (let i = 0; i < maxH; i++) {
        const row = $('<div></div>').addClass('row')
        for (let j = Math.min(0, xoffset); j <= Math.max(xadvance, right); j++) {
            const cell = $('<div></div>').addClass('cell').attr('data-x', j).attr('data-y', i)
            // These classes are used to position the "limits" vertical lines
            if (i === 0 && j === 0) {
                cell.addClass('before_xoffset')
            }
            if (i === 0 && j === xadvance) {
                cell.addClass('before_xadvance')
            }
            // Now draw the actual pixels
            if (i < top || i >= bottom || j < left || j >= right) {
                cell.addClass('dead')
            } else if (pixels.charAt((i - top) * width + (j - left)) == '1') {
                cell.addClass('fill')
            }
            // If the pixel is after xadvance, or before xoffset
            if (j >= xadvance || j < Math.max(0, xoffset)) {
                cell.addClass('over')
            }
            row.append(cell)
        }
        table.append(row)
    }

    // Draw the xadvance/xoffset limits
    // (We need to get the actual cell position before hand)
    const left_xoffset = table.find('div.before_xoffset')[0].offsetLeft
    xoffset_limit = $('<div class="xoffset_limit limit"></div>').css('left', (left_xoffset - 1) + 'px') // -1 accounts for first border of table
    table.append(xoffset_limit)

    const left_xadvance = table.find('div.before_xadvance')[0].offsetLeft
    xadvance_limit = $('<div class="xadvance_limit limit"></div>').css('left', (left_xadvance - 1) + 'px')
    table.append(xadvance_limit)

    // Set the baseline
    baseline = $('<div class="baseline"></div>').css('top', ((maxBaseline + 1) * 10 - 1) + 'px')
    table.append(baseline)
}

function updatePixels(table, newWidth, newHeight, x, y, fill) {
    const dataPixels = table.attr('data-pixels')
    const width = parseInt(table.attr('data-w'))
    const height = parseInt(table.attr('data-h'))
    const xoff = parseInt(table.attr('data-ow'))
    const base = parseInt(table.attr('data-oh'))
    const xAdjust = xoff * -1
    const yAdjust = (window['maxBaseline'] + base) * -1

    if (newWidth < 0) {
        newWidth = width
    }

    if (newHeight < 0) {
        newHeight = height
    }

    if (x >= 0 && y >= 0) {
        x += xAdjust
        y += yAdjust
    }

    // Store the pixels into a 2D bool array
    const array = []
    let pixelIndex = 0
    for (let i = 0; i < height; ++i) {
        const rowArray = []
        for (let j = 0; j < width; ++j) {
            if (x == j && y == i) {
                rowArray.push(fill)
            } else {
                rowArray.push(dataPixels.charAt(pixelIndex))
            }
            ++pixelIndex
        }
        array.push(rowArray)
    }

    // Write out to a string newWidth x newHeight
    let newPixels = ''
    for (let i = 0; i < newHeight; ++i) {
        for (let j = 0; j < newWidth; ++j) {
            if (i >= height || j >= width) {
                newPixels += '0'
            } else {
                newPixels += array[i][j]
            }
        }
    }

    // Pad out to a multiple of 8
    const pad = newPixels.length % 8
    for (let i = 0; i < pad; ++i) {
        newPixels += '0'
    }

    table.attr('data-pixels', newPixels)
}

function advanceLoading(percent) {
    const element = document.querySelector('#loader .advance')
    element.style.width = Math.floor(294 * percent)
}

function extractFont() {
    let data = $('#source').val()

    const bitmaps_part_re = /const\ uint8\_t\ (.*)Bitmaps\[\]/
    const glyph_part_re = /const\ GFXglyph/
    const font_part_re = /const\ GFXfont([\s\S]*)/g

    // Extract name
    const font_name = data.match(bitmaps_part_re)

    if (font_name != null && font_name.length > 1) {
        window['name'] = font_name[1]
    } else {
        alert('No correct font file found (name missing), please paste the content of an Adafruit GFX font file first.')
        $("#loader").hide()
        return
    }

    $('#glyphs').empty()

    // Extract GFXFont part
    const font_def = data.match(font_part_re)
    window['font_def'] = font_def[0]

    // Ignore any lines before the font definition (like headers, for instance)
    // In case the parts come out of order, cut the lines until the first of any
    // of the parts we are interested in.
    const slice_index = Math.min(
        data.indexOf(font_name[0]),
        data.indexOf(font_def[0]),
        data.search(glyph_part_re),
    )
    window.font_preamble = data.slice(0, slice_index)
    data = data.slice(slice_index)

    // Get first, last and yOffset
    let parts = font_def[0].split(',')
    const number_hexa_re = /0[xX][0-9a-fA-F]+/gi
    const number_dec_re = /[0-9]+/gi
    if (parts[2].match(number_hexa_re)) {
        window['first'] = parts[2].match(number_hexa_re)[0]
    } else if (parts[2].match(number_dec_re)) {
        window['first'] = '0x' + Number(parts[2].match(number_dec_re)[0]).toString(16)
    } else {
        alert('No correct font file found (first character offset unparsable), please paste the content of an Adafruit GFX font file first.')
        $("#loader").hide()
        return
    }

    if (parts[3].match(number_hexa_re)) {
        window['last'] = parts[3].match(number_hexa_re)[0]
    } else if (parts[3].match(number_dec_re)) {
        window['last'] = '0x' + Number(parts[3].match(number_dec_re)[0]).toString(16)
    } else {
        alert('No correct font file found (last character offset unparsable), please paste the content of an Adafruit GFX font file first.')
        $("#loader").hide()
        return
    }

    data = data.replace(font_def[0], '')
    data = data.replace(/\{/gi, '[').replace(/\}/gi, ']')
    data = data.replace('const GFXglyph ', '').replace('const uint8_t ', '').replace(/\[\]\ PROGMEM/gi, '')

    eval(data)

    /*
        // Tada 🎉
        console.log(window["name"])
        console.log(window["size"])
        console.log(window["first"])
        console.log(window["last"])
        console.log(window["font_def"])
        console.log(window[name + "Bitmaps"])
        console.log(window[name + "Glyphs"])
        */

    $('.fontname').text('(' + window['name'].slice(0, window['name'].length - 1) + ')').show()
    $('#firstglyph').val(window["first"])
    $('#lastglyph').val(window["last"])

    // $('#add').attr('disabled', false)

    const glyphsArray = window[name + 'Glyphs']

    // Run pre-calculations for correct display
    let maxW = 0
    let maxBaseline = 0
    let minUnderBaseline = 0
    for (ind in glyphsArray) {
        const inv_oh = -glyphsArray[ind][5]
        maxW = Math.max(maxW, glyphsArray[ind][1], glyphsArray[ind][3])
        maxBaseline = Math.max(maxBaseline, inv_oh)
        minUnderBaseline = Math.min(minUnderBaseline, inv_oh + 1 - glyphsArray[ind][2])
    }

    // Calculate the max height that we need for every glyph cell
    window['maxH'] = maxBaseline + 1 - minUnderBaseline

    // Space from the baseline to the top of the character cell is determined by the character with the
    // largest negative yOffset.
    window['maxBaseline'] = maxBaseline

    // Calculate the ideal glyph width. 160px is the minimum (for the buttons)
    window['glyph_table_width'] = Math.max(160, maxW * 11 + 30 /* some margin */ )

    // Display tables
    for (ind in glyphsArray) {
        const charIndex = parseInt(ind)
        // for each glyph
        const char = String.fromCharCode(parseInt(window['first'], 16) + charIndex)
        const w = glyphsArray[ind][1]
        const h = glyphsArray[ind][2]
        const adv = glyphsArray[ind][3]
        const ow = glyphsArray[ind][4]
        const oh = glyphsArray[ind][5]
        let n = ''

        // extract data: current offset
        currentOffset = glyphsArray[charIndex][0]

        // extract data: next offset
        if (charIndex + 1 < glyphsArray.length) {
            // To get the next offset, we need to find the next non-disabled
            // character offset (else, we will get 0 and it's not correct).
            let nextIndexIncrementor = 1
            do {
                nextOffset = glyphsArray[charIndex + nextIndexIncrementor][0]
                nextIndexIncrementor += 1
            } while (nextOffset === 0 && (charIndex + nextIndexIncrementor < glyphsArray.length))
            if (nextOffset === 0) { // We reached the end of the bitmaps
                nextOffset = window[name + 'Bitmaps'].length
            }
        } else {
            nextOffset = window[name + 'Bitmaps'].length
        }

        let disabled = (w == 0 || h == 0) && adv == 0

        if (!disabled) {
            for (let k = 0; k < (nextOffset - currentOffset); k++) {
                n += ('000000000' + window[name + 'Bitmaps'][currentOffset + k].toString(2)).substr(-8)
            }
        }

        grid = makeGlyphItem(n, w, h, char, adv, ow, oh, disabled)

        function glyphAppendClosure(el, adv) {
            setTimeout(function () {
                advanceLoading(0.2 * adv)
                $('#glyphs').append(el)
                if (adv === 1) {
                    // Run the setGlyphTable function now
                    displayGlyphTable()
                }
            }, 1)
        }

        glyphAppendClosure(grid, (charIndex + 1) / glyphsArray.length)
    }

    // $('#export').prop( "disabled", false )
    // $('#reset').prop("disabled", false)
    // $('#createFont').prop( "disabled", true )
    // $('#extract').prop( "disabled", true )
}

function displayGlyphTable() {
    const l = $('#glyphs').children().length
    $('#glyphs').children().each(function (i) {

        function setGlyphTableClosure(el, adv) {
            setTimeout(function () {
                advanceLoading(0.2 + 0.8 * adv)
                setGlyphTable(el.children().find('.glyph'))
                if (adv === 1) {
                    $('#loader').hide()
                }
            }, 1)
        }

        setGlyphTableClosure($(this), (i + 1) / l)
    })
}

$(document).ready(function () {

    var clip_data = {}

    $('#new-character-code').parent().hide()
    // $('#add').attr('disabled', 'disabled')
    // $('#export').attr('disabled', 'disabled')
    // $('#reset').prop("disabled", 'disabled')
    $('.ui.checkbox.use-charcode').checkbox()

    $(document).on('change', '.ui.checkbox.use-charcode input', function (e) {
        $('#new-character').parent().toggle()
        $('#new-character-code').parent().toggle()

        if ($('input[name=charcode]').is(':checked')) {
            if ($('#new-character-code').val() == '') {
                $('.character').text('N/A')
            } else {
                $('.character').text(String.fromCharCode(parseInt($('#new-character-code').val(), 16)))
            }
        } else {
            if ($('#new-character').val() == '') {
                $('.charcode').text('N/A')
            } else {
                $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
            }
        }
    })

    $('#newfont-new-character-code').parent().hide()
    $('.ui.checkbox.newfont-use-charcode').checkbox()
    $(document).on('change', '.ui.checkbox.newfont-use-charcode input', function (e) {
        $('#newfont-new-character').parent().toggle()
        $('#newfont-new-character-code').parent().toggle()

        if ($('input[name=newfontCharcode]').is(':checked')) {
            if ($('#newfont-new-character-code').val() == '') {
                $('.newfontCharacter').text('N/A')
            } else {
                $('.newfontCharacter').text(String.fromCharCode(parseInt($('#newfont-new-character-code').val(), 16)))
            }
        } else {
            if ($('#newfont-new-character').val() == '') {
                $('.newfontCharcode').text('N/A')
            } else {
                $('.newfontCharcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
            }
        }
    })

    $('#loader').hide()
    window['name'] = null
    window['font_def'] = null

    $('#clearText').click(function () {
        $('#source').val('')
    })

    $('#savefile').click(function () {
        var textToSave = document.getElementById("result").value; // Ambil teks dari elemen dengan id 'result'
        var textToSaveAsBlob = new Blob([textToSave], {
            type: "text/plain"
        }); // Buat Blob dari teks
        var textToSaveAsURL = window.URL.createObjectURL(textToSaveAsBlob); // Buat URL objek dari Blob

        var downloadLink = document.createElement("a"); // Membuat elemen <a> untuk link unduhan
        downloadLink.href = textToSaveAsURL; // Set link ke URL objek
        downloadLink.download = name + '.h'; // Tentukan nama file untuk diunduh
        downloadLink.innerHTML = "Download File"; // Teks untuk link (bisa diubah sesuai kebutuhan)
        downloadLink.onclick = function (event) {
            document.body.removeChild(event.target); // Hapus elemen setelah di-klik
        };
        downloadLink.style.display = "none"; // Sembunyikan link dari tampilan
        document.body.appendChild(downloadLink); // Tambahkan link ke body
        downloadLink.click(); // Klik link untuk memulai download
    });

    $('#reEdit').click(function () {
        let input = $('#result').val()
        if (input.length === 0) {
            document.getElementById("ErrorMsg").style.display = "block";
            setTimeout(function () {
                document.getElementById("ErrorMsg").style.display = "none";
            }, 1000);
            return;
        }
        $('#source').val('')
        $('#glyphs').empty()
        $('#source').val(input)
        extractFont()
        $('#result').val('')
    })


    $('#copyToClip').click(function () {

        var copyText = document.getElementById("result");
        copyText.select();
        copyText.setSelectionRange(0, 9999999); /*Change higher if all content not copied*/
        document.execCommand("copy");
    })
    $('#extract').click(function () {
        advanceLoading(0)
        $('#loader').fadeIn(function () {
            extractFont()
        })
    })

    $('#reset').click(function () {

        $('.ui.modal.confirmation p').text('The reset will close the font and discard any changes you made.')
        $('.ui.modal.confirmation').modal({
            closable: false,
            onApprove: function () {
                $('#glyphs').empty()
                $('#source').val('')
                // $('#createFont').prop("disabled", false)
                // $('#extract').prop("disabled", false)
                // $('#add').prop("disabled", "disabled")
                // $('#export').prop("disabled", "disabled")
                // $('#reset').prop("disabled", "disabled")
                $('.fontname').text('Fontname unknown').hide()
            }
        }).modal('show')
    })

    const fillPixel = (target, fill) => {
        fill === '1' ? target.addClass('fill') : target.removeClass('fill')
        const table = target.parent().parent().parent().find('.table.glyph')
        updatePixels(table, -1, -1, parseInt(target.attr('data-x')), parseInt(target.attr('data-y')), fill)
    }

    let isFilling = false;
    let fillingMode = '1';
    $(document).on('mousedown', '.cell:not(.dead)', function (e) {
        isFilling = true;
        fillingMode = $(e.target).hasClass('fill') ? '0' : '1'
        fillPixel($(e.target), fillingMode)
    })
    $(document).on('mouseup', '.cell:not(.dead)', function (e) {
        isFilling = false;
    })
    $(document).on('mouseenter', '.cell:not(.dead)', function (e) {
        if (isFilling) {
            fillPixel($(e.target), fillingMode)
        }
    })

    $(document).on('click', '.clip-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const actions = $(e.target).parent().parent()
        const table = actions.parent().find('.table.glyph')
        if (targetID === 'clip-copy') {
            clip_data.xadvance = parseInt(table.attr('data-adv'))
            clip_data.xoffset = parseInt(table.attr('data-ow'))
            clip_data.yoffset = parseInt(table.attr('data-oh'))
            clip_data.width = parseInt(table.attr('data-w'))
            clip_data.height = parseInt(table.attr('data-h'))
            clip_data.pixels = table.attr('data-pixels')
        } else if (targetID === 'clip-paste') {
            table.attr('data-adv', clip_data.xadvance)
            table.attr('data-ow', clip_data.xoffset)
            table.attr('data-oh', clip_data.yoffset)
            table.attr('data-w', clip_data.width)
            table.attr('data-h', clip_data.height)
            table.attr('data-pixels', clip_data.pixels)

            // Update button values
            actions.find('#row-value')[0].innerText = "Rows: " + clip_data.height
            actions.find('#col-value')[0].innerText = "Cols: " + clip_data.width
            actions.find('#base-value')[0].innerText = "Base: " + clip_data.yoffset
            actions.find('#xadv-value')[0].innerText = "XAdv: " + clip_data.xadvance
            actions.find('#xoff-value')[0].innerText = "XOff: " + clip_data.xoffset
        }
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.row-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#row-value')[0]

        let height = parseInt(table.attr('data-h'))

        if (targetID === 'row-add') {
            height++
        } else if (targetID === 'row-remove') {
            height--
        }

        updatePixels(table, -1, height, -1, -1, false)
        table.attr('data-h', height)
        valueDisplay.innerText = "Rows: " + height
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.col-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#col-value')[0]
        let width = parseInt(table.attr('data-w'))

        if (targetID === 'col-add') {
            width++
        } else if (targetID === 'col-remove') {
            width--
        }

        updatePixels(table, width, -1, -1, -1, false)
        table.attr('data-w', width)
        valueDisplay.innerText = "Cols: " + width
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.base-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#base-value')[0]
        let base = parseInt(table.attr('data-oh'))

        if (targetID === 'base-add') {
            base++
        } else if (targetID === 'base-remove') {
            base--
        }
        table.attr('data-oh', base)
        valueDisplay.innerText = "Base: " + base
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.xadv-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#xadv-value')[0]
        let xadv = parseInt(table.attr('data-adv'))

        if (targetID === 'xadv-add') {
            xadv++
        } else if (targetID === 'xadv-remove') {
            xadv--
        }
        table.attr('data-adv', xadv)
        valueDisplay.innerText = "XAdv: " + xadv
        setGlyphTable(table)
        return false
    })

    $(document).on('click', '.xoff-handler', function (e) {
        const targetID = $(e.target).attr('id')
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        const valueDisplay = $(e.target).parent().find('#xoff-value')[0]
        let ow = parseInt(table.attr('data-ow'))

        if (targetID === 'xoff-add') {
            ow++
        } else if (targetID === 'xoff-remove') {
            ow--
        }
        table.attr('data-ow', ow)
        valueDisplay.innerText = "XOff: " + ow

        setGlyphTable(table)
        return false
    })

    $(document).on('change', '.dis-handler', function (e) {
        const table = $(e.target).parent().parent().parent().find('.table.glyph')
        table.attr('data-dis', 1 - parseInt(table.attr('data-dis')))
        table.fadeTo('fast', 1 - 0.9 * table.attr('data-dis'))
        return false
    })

    $(document).on('keyup', '#new-character', function (e) {
        if ($('#new-character').val() == '') {
            $('.charcode').text('N/A')
        } else {
            $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
        }
    })

    $(document).on('keyup', '#new-character-code', function (e) {
        if ($('#new-character-code').val() == '') {
            $('.character').text('N/A')
        } else {
            $('.character').text(String.fromCharCode(parseInt($('#new-character-code').val(), 16)))
        }
    })

    $(document).on('keyup', '#newfont-new-character', function (e) {
        if ($('#newfont-new-character').val() == '') {
            $('.newfontCharcode').text('N/A')
        } else {
            $('.newfontCharcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
        }
    })

    $(document).on('keyup', '#newfont-new-character-code', function (e) {
        if ($('#newfont-new-character-code').val() == '') {
            $('.newfontCharacter').text('N/A')
        } else {
            $('.newfontCharacter').text(String.fromCharCode(parseInt($('#newfont-new-character-code').val(), 16)))
        }
    })

    $('#createFont').click(function () {
        $('input[name=newfontCharcode]').prop('checked', false)
        $('#newfont-new-character').parent().show()
        $('#newfont-new-character-code').parent().hide()
        if ($('#newfont-new-character').val() == '') {
            $('.charcode').text('N/A')
        } else {
            $('.charcode').text('0x' + $('#newfont-new-character').val().charCodeAt(0).toString(16).toUpperCase())
        }
        if ($('#newfont-new-character-code').val() == '') {
            $('.character').text('N/A')
        } else {
            $('.character').text(String.fromCharCode($('#newfont-new-character-code').val()))
        }

        $('.ui.modal.newfont').modal({
                closable: false,

                onApprove: function () {
                    let name = $('#newfont-name').val()
                    if (name.length < 1) {
                        $('.ui.modal.message p').text('The font must have a name, I\'m not creating a new font without it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }


                    let newfontHeight = parseInt($('#newfont-height').val())
                    if (newfontHeight < 1) {
                        $('.ui.modal.message p').text('The font height must be greater than 0, I\'m not creating a new font with this.')
                        $('.ui.modal.message').modal('show')
                        return
                    }


                    // Get new character data
                    let newChar
                    let newCharCode
                    if ($('input[name=newfontCharcode]').is(':checked')) {
                        newCharCode = parseInt($('#newfont-new-character-code').val(), 16)
                        newChar = String.fromCharCode(newCharCode)
                    } else {
                        newChar = $('#newfont-new-character').val()
                        newCharCode = $('#newfont-new-character').val().charCodeAt(0)
                    }

                    // Check character validity
                    if (newChar == '') {
                        $('.ui.modal.message p').text('This character is either blank or incorrect, I\'m not creating a new font with it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    if (newCharCode < 1) {
                        $('.ui.modal.message p').text('This is a special control character, I\'m not creating a new font with it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    if (newCharCode > 65535) {
                        $('.ui.modal.message p').text('This character is out of range, I\'m not creating a new font with it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    // Set the font parameters
                    window['first'] = newCharCode
                    window['last'] = newCharCode
                    window['name'] = name + '_'
                    window[name + '_Bitmaps'] = [] // This is otherwise created by the eval() in extract font
                    window['maxBaseline'] = newfontHeight
                    window['maxH'] = newfontHeight
                    window['font_def'] = 'const GFXfont ' + name + ' PROGMEM = {(uint8_t *) ' + name + '_Bitmaps, (GFXglyph *)' + name + '_Glyphs, 0x00, 0x00, ' + newfontHeight + '};'

                    // Show the data
                    $('.fontname').text('(' + name + ')').show()
                    $('#firstglyph').val('0x' + window["first"].toString(16))
                    $('#lastglyph').val('0x' + window["last"].toString(16))
                    $('#glyphs').empty()


                    // Change button states
                    $('#add').attr('disabled', false)
                    $('#export').prop("disabled", false)
                    $('#createFont').prop("disabled", true)
                    $('#extract').prop("disabled", true)
                    $('#reset').prop("disabled", false)

                    // Add the new character
                    const grid = makeGlyphItem(' ', 1, 1, newChar, 4, 0, -newfontHeight, false)
                    $('#glyphs').append(grid)

                    setGlyphTable(grid.find('.glyph'))
                }
            })
            .modal('show')
    })

    $('#add').click(function () {
        $('input[name=charcode]').prop('checked', false)
        $('#new-character').parent().show()
        $('#new-character-code').parent().hide()
        if ($('#new-character').val() == '') {
            $('.charcode').text('N/A')
        } else {
            $('.charcode').text('0x' + $('#new-character').val().charCodeAt(0).toString(16).toUpperCase())
        }
        if ($('#new-character-code').val() == '') {
            $('.character').text('N/A')
        } else {
            $('.character').text(String.fromCharCode($('#new-character-code').val()))
        }

        // Choose a character
        $('.ui.modal.choose').modal({
                closable: false,
                onApprove: function () {
                    const firstglyph = parseInt($('#firstglyph').val(), 16)
                    const lastglyph = parseInt($('#lastglyph').val(), 16)

                    let newChar
                    let newCharCode
                    if ($('input[name=charcode]').is(':checked')) {
                        newCharCode = parseInt($('#new-character-code').val(), 16)
                        newChar = String.fromCharCode(newCharCode)
                    } else {
                        newChar = $('#new-character').val()
                        newCharCode = $('#new-character').val().charCodeAt(0)
                    }

                    if (newChar == '') {
                        $('.ui.modal.message p').text('This character is either blank or incorrect, I\'m not adding it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    if (newCharCode < 1) {
                        $('.ui.modal.message p').text('This is a special control character, I\'m not adding it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    if (newCharCode > 65535) {
                        $('.ui.modal.message p').text('This character is out of range, I\'m not adding it.')
                        $('.ui.modal.message').modal('show')
                        return
                    }

                    // Check that the character is not already existing
                    if (newCharCode > lastglyph || newCharCode < firstglyph) {
                        let start, end;
                        if (newCharCode > lastglyph) {
                            start = lastglyph + 1
                            end = newCharCode
                            window['last'] = '0x' + newCharCode.toString(16).toUpperCase()
                            $('#lastglyph').val(window['last'])
                        } else {
                            start = newCharCode
                            end = firstglyph - 1
                            window['first'] = '0x' + newCharCode.toString(16).toUpperCase()
                            $('#firstglyph').val(window['first'])
                        }

                        if (newCharCode < firstglyph) {
                            for (j = end; j >= start; j--) {
                                const char = String.fromCharCode(parseInt(j))
                                const grid = makeGlyphItem(' ', 1, 1, char, 4, 0, -window['maxBaseline'], !(j === newCharCode))
                                $('#glyphs').prepend(grid)
                                setGlyphTable(grid.find('.glyph'))
                            }
                        } else {
                            for (j = start; j <= end; j++) {
                                const char = String.fromCharCode(parseInt(j))
                                const grid = makeGlyphItem(' ', 1, 1, char, 4, 0, -window['maxBaseline'], !(j === newCharCode))
                                $('#glyphs').append(grid)
                                setGlyphTable(grid.find('.glyph'))
                            }
                        }

                    } else {
                        $('.ui.modal.message p').text('This character is already present in the actual set, I\'m not adding it.')
                        $('.ui.modal.message').modal('show')
                    }
                }
            })
            .modal('show');

    })

    $('#export').click(function () {
        const glyphs = []
        const bitsArray = []
        let offset = 0
        const firstglyph = parseInt($('#firstglyph').val(), 16)
        const lastglyph = parseInt($('#lastglyph').val(), 16)

        $('.table.glyph').each(function () {
            const t = $(this)
            // Ignore glyphs outside of requested range
            if (t.attr('data-char').charCodeAt(0) < firstglyph || t.attr('data-char').charCodeAt(0) > lastglyph) {
                return
            }

            var dataPixels = $(this).attr('data-pixels')
            if (t.attr('data-dis') == 1) {
                dataPixels = ''
            }
            let bits = ''

            for (let i = 0; i < dataPixels.length; i++) {
                bits += dataPixels.charAt(i)
                // Each 8 bits, we form the HEX value
                if (bits.length == 8) {
                    bitsArray.push('0x' + ('00' + parseInt((bits + '00000000').slice(0, 8), 2).toString(16).toUpperCase()).slice(-2))
                    bits = ''
                }
            }

            // Remaining bits with padding then, if necessary
            if (bits != '') {
                bitsArray.push('0x' + ('00' + parseInt((bits + '00000000').slice(0, 8), 2).toString(16).toUpperCase()).slice(-2))
            }

            // Set data width/height to 0 for disabled glyphs
            const w = parseInt(t.attr('data-w')) * (1 - parseInt(t.attr('data-dis')))
            const h = parseInt(t.attr('data-h')) * (1 - parseInt(t.attr('data-dis')))

            let char = t.attr('data-char')
            const charCode = char.charCodeAt(0).toString(16).toUpperCase()
            const charDisplay = char.replace(/[\x00-\x1F\x7F-\x9F\xAD]/g, 'non-printable')
            const comment = '// 0x' + charCode + ' \'' + charDisplay + '\''

            if (t.attr('data-dis') == 0) {
                glyphs.push(
                    '  { ' +
                    ('     ' + offset).slice(-5) + ', ' +
                    ('   ' + w).slice(-3) + ', ' +
                    ('   ' + h).slice(-3) + ', ' +
                    ('   ' + parseInt(t.attr('data-adv'))).slice(-3) + ', ' +
                    ('    ' + parseInt(t.attr('data-ow'))).slice(-4) + ', ' +
                    ('    ' + parseInt(t.attr('data-oh'))).slice(-4) + ' },   ' +
                    comment)
            } else {
                glyphs.push(
                    '  { ' +
                    '    0, ' +
                    '  0, ' +
                    '  0, ' +
                    '  0, ' +
                    '   0, ' +
                    '   0 },   ' +
                    comment)
            }

            offset = bitsArray.length
        })

        // Bitmaps
        let bitmapsOutput = 'const uint8_t ' + name + 'Bitmaps[] PROGMEM = {\n'
        // We want to join per 12 words
        const limit = Math.floor(bitsArray.length / 12)
        for (let nb = 0; nb < limit; nb++) {
            const isLastLine = (limit * 12 === bitsArray.length) && (nb === limit - 1)

            bitmapsOutput += '  ' + bitsArray[nb * 12] + ', ' +
                bitsArray[nb * 12 + 1] + ', ' +
                bitsArray[nb * 12 + 2] + ', ' +
                bitsArray[nb * 12 + 3] + ', ' +
                bitsArray[nb * 12 + 4] + ', ' +
                bitsArray[nb * 12 + 5] + ', ' +
                bitsArray[nb * 12 + 6] + ', ' +
                bitsArray[nb * 12 + 7] + ', ' +
                bitsArray[nb * 12 + 8] + ', ' +
                bitsArray[nb * 12 + 9] + ', ' +
                bitsArray[nb * 12 + 10] + ', ' +
                bitsArray[nb * 12 + 11] + (isLastLine ? '' : ',') + ' \n'
        }

        if (limit * 12 !== bitsArray.length) {
            bitmapsOutput += '  ' + bitsArray.slice(-(bitsArray.length - limit * 12)).join(', ') + '\n'
        }
        bitmapsOutput += '};\n\n'

        // Glyphs
        // The last glyph has a ',' too much at the end, we need to remove it (it's easier than to avoid putting it in the first place)
        glyphs[glyphs.length - 1] = glyphs[glyphs.length - 1].replace('},', '} ')
        let glyphsOutput = 'const GFXglyph ' + name + 'Glyphs[] PROGMEM = {\n'
        glyphsOutput += glyphs.join('\n') + '\n};\n\n'

        // Create a new font_def with the updated first & last glyph values in it
        let parts = window['font_def'].split(',')
        parts[2] = '0x' + firstglyph.toString(16).toUpperCase()
        parts[3] = '0x' + lastglyph.toString(16).toUpperCase()
        const updated_font_def = parts.join(", ", parts)

        data = bitmapsOutput + glyphsOutput + updated_font_def

        // Add back the font preamble, if present
        data = (window.font_preamble ?? '') + data

        $('#result').val(data)
    })
})
</script>
</html>
